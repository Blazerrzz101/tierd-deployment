"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([["main-app-node_modules_next_dist_client_components_b"],{"(app-pages-browser)/../node_modules/next/dist/client/components/bailout-to-client-rendering.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "bailoutToClientRendering", ({\n    enumerable: true,\n    get: function() {\n        return bailoutToClientRendering;\n    }\n}));\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ "(app-pages-browser)/../node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js");\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ "(shared)/../node_modules/next/dist/client/components/static-generation-async-storage.external.js");\nfunction bailoutToClientRendering(reason) {\n    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new _bailouttocsr.BailoutToCSRError(reason);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=bailout-to-client-rendering.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2JhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OzREQUdnQkE7OztlQUFBQTs7OzBDQUhrQjtrRUFDVztBQUV0QyxTQUFTQSx5QkFBeUJDLE1BQWM7SUFDckQsTUFBTUMsd0JBQXdCQyxzQ0FBQUEsNEJBQTRCLENBQUNDLFFBQVE7SUFFbkUsSUFBSUYseUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHNCQUF1QkcsV0FBVyxFQUFFO0lBRXhDLElBQUlILHlCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxzQkFBdUJJLGtCQUFrQixFQUMzQyxNQUFNLElBQUlDLGNBQUFBLGlCQUFpQixDQUFDTjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL2JhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZy50cz9iYmQ4Il0sIm5hbWVzIjpbImJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyIsInJlYXNvbiIsInN0YXRpY0dlbmVyYXRpb25TdG9yZSIsInN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsImZvcmNlU3RhdGljIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiQmFpbG91dFRvQ1NSRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/bailout-to-client-rendering.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/dev-root-not-found-boundary.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DevRootNotFoundBoundary: function() {\n        return DevRootNotFoundBoundary;\n    },\n    bailOnNotFound: function() {\n        return bailOnNotFound;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ "(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js"));\nconst _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ "(app-pages-browser)/../node_modules/next/dist/client/components/not-found-boundary.js");\nfunction bailOnNotFound() {\n    throw new Error("notFound() is not allowed to use in root layout");\n}\nfunction NotAllowedRootNotFoundError() {\n    bailOnNotFound();\n    return null;\n}\n_c = NotAllowedRootNotFoundError;\nfunction DevRootNotFoundBoundary(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_notfoundboundary.NotFoundBoundary, {\n        notFound: /*#__PURE__*/ (0, _jsxruntime.jsx)(NotAllowedRootNotFoundError, {}),\n        children: children\n    });\n}\n_c1 = DevRootNotFoundBoundary;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dev-root-not-found-boundary.js.map\nvar _c, _c1;\n$RefreshReg$(_c, "NotAllowedRootNotFoundError");\n$RefreshReg$(_c1, "DevRootNotFoundBoundary");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Rldi1yb290LW5vdC1mb3VuZC1ib3VuZGFyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQWNnQkEsU0FBQUE7NkJBQUFBOztJQVRBQztvQkFBQUE7Ozs7OztzREFGaUJDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7QUFFMUIsTUFBQUMsb0JBQVNILG1CQUFBQSxDQUFBQSxtSEFBQUE7U0FDZEE7SUFDRixVQUFBSSxNQUFBO0FBRUE7U0FDRUo7SUFDQUE7SUFDRjtBQUVPO0tBSkxBO1NBSXNDRCx3QkFBQU0sS0FBQTtJQUt0QyxNQUFBQyxRQUFBLEtBQUFEO1dBQ29CRSxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFVQyxHQUFBLEVBQUFMLGtCQUFDTSxnQkFBQUEsRUFBQUE7a0JBQzFCSCxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSw2QkFBQUEsQ0FBQUE7O0lBR1A7O01BVndDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL2Rldi1yb290LW5vdC1mb3VuZC1ib3VuZGFyeS50c3g/MjY0YyJdLCJuYW1lcyI6WyJEZXZSb290Tm90Rm91bmRCb3VuZGFyeSIsImJhaWxPbk5vdEZvdW5kIiwiXyIsInJlcXVpcmUiLCJfbm90Zm91bmRib3VuZGFyeSIsIkVycm9yIiwicGFyYW0iLCJjaGlsZHJlbiIsIm5vdEZvdW5kIiwianN4IiwiTm90QWxsb3dlZFJvb3ROb3RGb3VuZEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/dev-root-not-found-boundary.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/error-boundary.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ErrorBoundary: function() {\n        return ErrorBoundary;\n    },\n    ErrorBoundaryHandler: function() {\n        return ErrorBoundaryHandler;\n    },\n    GlobalError: function() {\n        return GlobalError;\n    },\n    // Exported so that the import signature in the loaders can be identical to user\n    // supplied custom global error signatures.\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ "(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js"));\nconst _navigation = __webpack_require__(/*! ./navigation */ "(app-pages-browser)/../node_modules/next/dist/client/components/navigation.js");\nconst _isnextroutererror = __webpack_require__(/*! ./is-next-router-error */ "(app-pages-browser)/../node_modules/next/dist/client/components/is-next-router-error.js");\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ "(shared)/../node_modules/next/dist/client/components/static-generation-async-storage.external.js");\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: \'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"\',\n        height: "100vh",\n        textAlign: "center",\n        display: "flex",\n        flexDirection: "column",\n        alignItems: "center",\n        justifyContent: "center"\n    },\n    text: {\n        fontSize: "14px",\n        fontWeight: 400,\n        lineHeight: "28px",\n        margin: "0 8px"\n    }\n};\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nfunction HandleISRError(param) {\n    let { error } = param;\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {\n        console.error(error);\n        throw error;\n    }\n    return null;\n}\n_c = HandleISRError;\nclass ErrorBoundaryHandler extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((0, _isnextroutererror.isNextRouterError)(error)) {\n            // Re-throw if an expected internal Next.js router error occurs\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n            throw error;\n        }\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.error) {\n            return {\n                error: null,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            error: state.error,\n            previousPathname: props.pathname\n        };\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleISRError, {\n                        error: this.state.error\n                    }),\n                    this.props.errorStyles,\n                    this.props.errorScripts,\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {\n                        error: this.state.error,\n                        reset: this.reset\n                    })\n                ]\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null,\n            previousPathname: this.props.pathname\n        };\n    }\n}\nfunction GlobalError(param) {\n    let { error } = param;\n    const digest = error == null ? void 0 : error.digest;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {\n        id: "__next_error__",\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)("body", {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleISRError, {\n                        error: error\n                    }),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {\n                        style: styles.error,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {\n                            children: [\n                                /*#__PURE__*/ (0, _jsxruntime.jsx)("h2", {\n                                    style: styles.text,\n                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."\n                                }),\n                                digest ? /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {\n                                    style: styles.text,\n                                    children: "Digest: " + digest\n                                }) : null\n                            ]\n                        })\n                    })\n                ]\n            })\n        ]\n    });\n}\n_c1 = GlobalError;\nconst _default = GlobalError;\nfunction ErrorBoundary(param) {\n    let { errorComponent, errorStyles, errorScripts, children } = param;\n    const pathname = (0, _navigation.usePathname)();\n    if (errorComponent) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {\n            pathname: pathname,\n            errorComponent: errorComponent,\n            errorStyles: errorStyles,\n            errorScripts: errorScripts,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = ErrorBoundary;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, "HandleISRError");\n$RefreshReg$(_c1, "GlobalError");\n$RefreshReg$(_c2, "ErrorBoundary");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBb0tnQkEsU0FBYTttQkFBYkE7O0lBdEdIQzswQkFBQUE7O0lBaUVHQztpQkFBQUE7O0lBd0JoQjtJQUNBLGdGQUEyQztJQUMzQywyQ0FBMEI7Ozs7Ozs7NkJBdEpFQyx5QkFBQUMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTs7O0FBSTVCLE1BQU1DLHdDQUFTRCxtQkFBQUEsQ0FBQTtNQUNiRSxTQUFPO1dBQ0w7UUFDQUMsMEZBQ0U7UUFDRkMsWUFBUTtRQUNSQyxRQUFBQTtRQUNBQyxXQUFTO1FBQ1RDLFNBQUFBO1FBQ0FDLGVBQVk7UUFDWkMsWUFBQUE7UUFDRkEsZ0JBQUE7SUFDQUM7VUFDRUM7UUFDQUMsVUFBQUE7UUFDQUMsWUFBWTtRQUNaQyxZQUFRO1FBQ1ZBLFFBQUE7SUFDRjtBQXdCQTtBQUNBLDhEQUF5RDtBQUN6RCx5REFBb0M7QUFDcEMsb0NBQWlEO1NBQXpCQyxlQUFBQyxLQUFBO0lBQ3RCLE1BQU1DLEtBQUFBLEVBQUFBLEdBQVFDO0lBQ2QsTUFBSUQsUUFBQUEsc0NBQW1CQyw0QkFBSUQsQ0FBQUEsUUFBT0U7UUFDaENDLENBQUFBLFNBQVFsQixPQUFNQSxLQUFBQSxJQUFBQSxNQUFBQSxZQUFBQSxLQUFBQSxDQUFBQSxTQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxNQUFBQSxrQkFBQUEsR0FBQUE7UUFDZGtCLFFBQU1sQixLQUFBQSxDQUFBQTtRQUNSLE1BQUFBO0lBRUE7SUFDRjtBQUVPO0tBVmlCYTtNQW1CdEJuQiw2QkFBT3lCLE9BQXFDQyxPQUFFLENBQUFDLFNBQUE7V0FDNUNGLHlCQUFJRyxLQUFBQSxFQUFBQTtZQUNGLElBQUFDLG1CQUFBRCxpQkFBQSxFQUFBdEIsUUFBQTtZQUNBO1lBQ0EsNEdBQU1BO1lBQ1IsTUFBQUE7UUFFQTtlQUFTQTtZQUFNQTtRQUNqQjtJQUVBO1dBSUV3Qix5QkFBQUMsS0FBQSxFQUFBQyxLQUFBOzs7Ozs7WUFPRUQsTUFBQUUsUUFBTyxLQUFBRCxNQUFBRSxnQkFBQSxJQUFBRixNQUFBMUIsS0FBQTttQkFDTEE7Z0JBQ0E0QixPQUFBQTtnQkFDRkEsa0JBQUFILE1BQUFFLFFBQUE7WUFDRjtRQUNBO2VBQ0UzQjtZQUNBNEIsT0FBQUEsTUFBQUEsS0FBa0JIO1lBQ3BCRyxrQkFBQUgsTUFBQUUsUUFBQTtRQUNGO0lBTUE7SUFDQUUsMElBQTBCO2FBQ3BCO1lBQ0YsS0FBQUgsS0FBQSxDQUFBMUIsS0FBQTs7OytCQUUyQixHQUFJLElBQUMwQixZQUFXSSxHQUFBLEVBQUFqQixnQkFBQTs7b0JBQ3RDO29CQUNBLElBQUksQ0FBQ1ksS0FBSyxDQUFDTSxXQUFBQTsyQ0FDWjsrQkFDUyxHQUFJLElBQUNMLFlBQVdJLEdBQUEsT0FBQUwsS0FBQSxDQUFBTyxjQUFBO3dCQUN2QkMsT0FBTyxJQUFJLENBQUNBLEtBQUssQ0FBQWpDLEtBQUE7Ozs7WUFJekI7UUFFQTtRQUNGLFlBQUF5QixLQUFBLENBQUFTLFFBQUE7SUExREFDO2dCQUNRVixLQUFBQSxDQUFBQTthQW9DUlEsQ0FBQUE7WUFDRSxDQUFBQSxLQUFLRyxHQUFBQTtnQkFBV3BDLENBQUFBLFFBQU87Z0JBQUtBLE9BQUE7WUFDOUI7UUFyQ0U7WUFBZUEsQ0FBQUEsS0FBQUEsR0FBTztZQUFNNEIsT0FBQUE7WUFBc0NBLGtCQUFBLEtBQUFILEtBQUEsQ0FBQUUsUUFBQTtRQUNwRTtJQXdERjtBQUVPO1NBQXFCaEMsWUFBQW1CLEtBQUE7SUFDMUIsTUFBTXVCLEtBQUFBLEVBQUFBLEdBQTZCckM7SUFDbkMsTUFBQXFDLFNBQUFyQyxTQUNFLGdCQUFBQSxNQUFDc0MsTUFBQUE7V0FBUSxrQkFBQUUsWUFBQUMsSUFBQTs7OzBCQUVQLElBQUFELFlBQUFWLEdBQUEsVUFBQ1ksQ0FBQUE7OzsrQkFDd0IxQyxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxnQkFBQUE7OzsrQkFDWEQsR0FBQUEsQ0FBQUEsR0FBT0MsWUFBSzhCLEdBQUE7c0NBQ3RCOUIsS0FBQTs7OzJDQUNhRCxHQUFBQSxDQUFBQSxHQUFPUyxZQUFJc0IsR0FBQTtrREFDbEJ0QixJQUFBOztnQ0FNSDZCO3lDQUE4QixXQUFKN0IsR0FBSSxJQUFBZ0MsWUFBQVYsR0FBQTtrREFBSXRCLElBQUE7OENBQTBCLGFBQUE2Qjs7Ozs7Ozs7SUFNekU7O01BdEI0QjFDO0FBcUNyQixNQUFBaUQsV0FBU25EO1NBQWNBLGNBQzVCdUMsS0FDQWE7SUFJQSxNQUFNbEIsY0FBV21CLEVBQUFBLFdBQUFBLEVBQUFBLFlBQVcsRUFBQVosUUFBQSxLQUFBcEI7SUFDNUIsTUFBSWtCLFdBQUFBLENBQUFBLEdBQWdCZSxZQUFBRCxXQUFBO1FBQ2xCZCxnQkFBQTtlQUVjTCxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxzQkFBQUE7WUFDVkssVUFBQUE7WUFDQWEsZ0JBQWFBO1lBQ2JkLGFBQUFBOzBCQUVDRzs7UUFHUDtJQUVBO1dBQVVBLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLFlBQUFBLEdBQUFBLEVBQUFBLFlBQUFBLFFBQUFBLEVBQUFBOztJQUNaOztNQXJCOEJ6QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LnRzeD82NjU5Il0sIm5hbWVzIjpbIkVycm9yQm91bmRhcnkiLCJFcnJvckJvdW5kYXJ5SGFuZGxlciIsIkdsb2JhbEVycm9yIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiXyIsInJlcXVpcmUiLCJzdHlsZXMiLCJlcnJvciIsImZvbnRGYW1pbHkiLCJoZWlnaHQiLCJ0ZXh0QWxpZ24iLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsInRleHQiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0IiwibWFyZ2luIiwiSGFuZGxlSVNSRXJyb3IiLCJwYXJhbSIsInN0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImNvbnNvbGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJkZWZhdWx0IiwiQ29tcG9uZW50IiwiaXNOZXh0Um91dGVyRXJyb3IiLCJfaXNuZXh0cm91dGVyZXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wcyIsInN0YXRlIiwicGF0aG5hbWUiLCJwcmV2aW91c1BhdGhuYW1lIiwicmVuZGVyIiwianN4IiwiZXJyb3JTY3JpcHRzIiwiZXJyb3JDb21wb25lbnQiLCJyZXNldCIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJzZXRTdGF0ZSIsImRpZ2VzdCIsImh0bWwiLCJpZCIsIl9qc3hydW50aW1lIiwianN4cyIsImJvZHkiLCJzdHlsZSIsIl9kZWZhdWx0IiwiZXJyb3JTdHlsZXMiLCJ1c2VQYXRobmFtZSIsIl9uYXZpZ2F0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/error-boundary.js\n'))}}]);
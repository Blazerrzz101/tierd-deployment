(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([["main-app-node_modules_next_dist_client_components_s"],{"(shared)/../node_modules/next/dist/client/components/static-generation-async-storage.external.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('"TURBOPACK { transition: next-shared }";\n"use strict";\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "staticGenerationAsyncStorage", ({\n    enumerable: true,\n    get: function() {\n        return _staticgenerationasyncstorageinstance.staticGenerationAsyncStorage;\n    }\n}));\nconst _staticgenerationasyncstorageinstance = __webpack_require__(/*! ./static-generation-async-storage-instance */ "(shared)/../node_modules/next/dist/client/components/static-generation-async-storage-instance.js");\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-async-storage.external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNoYXJlZCkvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLmV4dGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQVNFOzs7OztnRUFtRE9BOzs7ZUFBQUEsc0NBQUFBLDRCQUE0Qjs7O2tFQWxEUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwudHM/MjJiNyJdLCJuYW1lcyI6WyJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(shared)/../node_modules/next/dist/client/components/static-generation-async-storage.external.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/unresolved-thenable.js":function(module,exports,__webpack_require__){"use strict";eval(__webpack_require__.ts('/**\n * Create a "Thenable" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "unresolvedThenable", ({\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n}));\nconst unresolvedThenable = {\n    then: ()=>{}\n};\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unresolved-thenable.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VucmVzb2x2ZWQtdGhlbmFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7c0RBQ1lBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHFCQUFxQjtJQUNoQ0MsTUFBTSxLQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy91bnJlc29sdmVkLXRoZW5hYmxlLnRzPzQwMzYiXSwibmFtZXMiOlsidW5yZXNvbHZlZFRoZW5hYmxlIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/unresolved-thenable.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/use-reducer-with-devtools.js":function(module,exports,__webpack_require__){"use strict";eval(__webpack_require__.ts('\nvar _s = $RefreshSig$();\n"use strict";\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    useReducerWithReduxDevtools: function() {\n        return useReducerWithReduxDevtools;\n    },\n    useUnwrapState: function() {\n        return useUnwrapState;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js"));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _actionqueue = __webpack_require__(/*! ../../shared/lib/router/action-queue */ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/action-queue.js");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === "function") {\n                obj[key] = "fn()";\n                continue;\n            }\n            if (typeof value === "object" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = "FlightData";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === "object" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === "function") {\n                obj[key] = "fn()";\n                continue;\n            }\n            if (typeof value === "object" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty("_bundlerConfig")) {\n                    obj[key] = "FlightData";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction useUnwrapState(state) {\n    // reducer actions can be async, so sometimes we need to suspend until the state is resolved\n    if ((0, _routerreducertypes.isThenable)(state)) {\n        const result = (0, _react.use)(state);\n        return result;\n    }\n    return state;\n}\nfunction useReducerWithReduxDevtoolsNoop(initialState) {\n    return [\n        initialState,\n        ()=>{},\n        ()=>{}\n    ];\n}\nfunction useReducerWithReduxDevtoolsImpl(initialState) {\n    _s();\n    const [state, setState] = _react.default.useState(initialState);\n    const actionQueue = (0, _react.useContext)(_actionqueue.ActionQueueContext);\n    if (!actionQueue) {\n        throw new Error("Invariant: Missing ActionQueueContext");\n    }\n    const devtoolsConnectionRef = (0, _react.useRef)();\n    const enabledRef = (0, _react.useRef)();\n    (0, _react.useEffect)(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === "undefined") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 8000,\n            name: "next-router"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n            if (actionQueue) {\n                actionQueue.devToolsInstance = devtoolsConnectionRef.current;\n            }\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState,\n        actionQueue\n    ]);\n    const dispatch = (0, _react.useCallback)((action)=>{\n        if (!actionQueue.state) {\n            // we lazy initialize the mutable action queue state since the data needed\n            // to generate the state is not available when the actionQueue context is created\n            actionQueue.state = initialState;\n        }\n        actionQueue.dispatch(action, setState);\n    }, [\n        actionQueue,\n        initialState\n    ]);\n    // Sync is called after a state update in the HistoryUpdater,\n    // for debugging purposes. Since the reducer state may be a Promise,\n    // we let the app router use() it and sync on the resolved value if\n    // something changed.\n    // Using the `state` here would be referentially unstable and cause\n    // undesirable re-renders and history updates.\n    const sync = (0, _react.useCallback)((resolvedState)=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: "RENDER_SYNC"\n            }, normalizeRouterState(resolvedState));\n        }\n    }, []);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\n_s(useReducerWithReduxDevtoolsImpl, "2/eSVXfk2V5ZKttKXeUPXMa6Sd8=");\nconst useReducerWithReduxDevtools = typeof window !== "undefined" ? useReducerWithReduxDevtoolsImpl : useReducerWithReduxDevtoolsNoop;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUEyS2FBLDZCQUEyQjtlQUEzQkE7O0lBN0ZHQyxnQkFBYztlQUFkQTs7Ozs2RUE3RXVCO2dEQU9oQzt5Q0FDNEI7QUFJbkMsU0FBU0MscUJBQXFCQyxHQUFRO0lBQ3BDLElBQUlBLGVBQWVDLEtBQUs7UUFDdEIsTUFBTUMsTUFBOEIsQ0FBQztRQUNyQyxLQUFLLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTSxJQUFJSixJQUFJSyxPQUFPLEdBQUk7WUFDeEMsSUFBSSxPQUFPRCxVQUFVLFlBQVk7Z0JBQy9CRixHQUFHLENBQUNDLElBQUksR0FBRztnQkFDWDtZQUNGO1lBQ0EsSUFBSSxPQUFPQyxVQUFVLFlBQVlBLFVBQVUsTUFBTTtnQkFDL0MsSUFBSUEsTUFBTUUsUUFBUSxFQUFFO29CQUNsQkosR0FBRyxDQUFDQyxJQUFJLEdBQUdDLE1BQU1FLFFBQVEsQ0FBQ0MsUUFBUTtvQkFDbEM7Z0JBQ0Y7Z0JBQ0EsSUFBSUgsTUFBTUksY0FBYyxFQUFFO29CQUN4Qk4sR0FBRyxDQUFDQyxJQUFJLEdBQUc7b0JBQ1g7Z0JBQ0Y7WUFDRjtZQUNBRCxHQUFHLENBQUNDLElBQUksR0FBR0oscUJBQXFCSztRQUNsQztRQUNBLE9BQU9GO0lBQ1Q7SUFFQSxJQUFJLE9BQU9GLFFBQVEsWUFBWUEsUUFBUSxNQUFNO1FBQzNDLE1BQU1FLE1BQThCLENBQUM7UUFDckMsSUFBSyxNQUFNQyxPQUFPSCxJQUFLO1lBQ3JCLE1BQU1JLFFBQVFKLEdBQUcsQ0FBQ0csSUFBSTtZQUN0QixJQUFJLE9BQU9DLFVBQVUsWUFBWTtnQkFDL0JGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO2dCQUNYO1lBQ0Y7WUFDQSxJQUFJLE9BQU9DLFVBQVUsWUFBWUEsVUFBVSxNQUFNO2dCQUMvQyxJQUFJ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O0FBQ2hDO0dBM0VTeEI7QUE2RUYsTUFBTXRCLDhCQUNYLE9BQU9vQyxXQUFXLGNBQ2RkLGtDQUNBRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMudHM/NGUzYiJdLCJuYW1lcyI6WyJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJ1c2VVbndyYXBTdGF0ZSIsIm5vcm1hbGl6ZVJvdXRlclN0YXRlIiwidmFsIiwiTWFwIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiJCR0eXBlb2YiLCJ0b1N0cmluZyIsIl9idW5kbGVyQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJzdGF0ZSIsImlzVGhlbmFibGUiLCJyZXN1bHQiLCJ1c2UiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbCIsInNldFN0YXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsImFjdGlvblF1ZXVlIiwidXNlQ29udGV4dCIsIkFjdGlvblF1ZXVlQ29udGV4dCIsIkVycm9yIiwiZGV2dG9vbHNDb25uZWN0aW9uUmVmIiwidXNlUmVmIiwiZW5hYmxlZFJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwiY29ubmVjdCIsImluc3RhbmNlSWQiLCJuYW1lIiwiaW5pdCIsImRldlRvb2xzSW5zdGFuY2UiLCJkaXNwYXRjaCIsInVzZUNhbGxiYWNrIiwiYWN0aW9uIiwic3luYyIsInJlc29sdmVkU3RhdGUiLCJzZW5kIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/use-reducer-with-devtools.js\n'))},"(shared)/../node_modules/next/dist/client/components/static-generation-async-storage-instance.js":function(module,exports,__webpack_require__){"use strict";eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "staticGenerationAsyncStorage", ({\n    enumerable: true,\n    get: function() {\n        return staticGenerationAsyncStorage;\n    }\n}));\nconst _asynclocalstorage = __webpack_require__(/*! ./async-local-storage */ "(shared)/../node_modules/next/dist/client/components/async-local-storage.js");\nconst staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-async-storage-instance.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNoYXJlZCkvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLWluc3RhbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0VBR2FBOzs7ZUFBQUE7OzsrQ0FGMkI7QUFFakMsTUFBTUEsK0JBQ1hDLENBQUFBLEdBQUFBLG1CQUFBQSx1QkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLWluc3RhbmNlLnRzP2Y3MjYiXSwibmFtZXMiOlsic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(shared)/../node_modules/next/dist/client/components/static-generation-async-storage-instance.js\n'))}}]);
"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([["main-app-node_modules_next_dist_client_components_router-reducer_p"],{"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    updateCacheNodeOnNavigation: function() {\n        return updateCacheNodeOnNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/../node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.PAGE_SEGMENT_KEY) {\n            // This is a leaf segment — a page, not a shared layout. We always apply\n            // its data.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        } else if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment — a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation — but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else if (oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees.\n                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n                    // Recursively update the children.\n                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);\n                } else {\n                    // The server didn't send any prefetch data for this segment. This\n                    // shouldn't happen because the Route Tree and the Seed Data tree\n                    // should always be the same shape, but until we unify those types\n                    // it's still possible. For now we're going to deopt and trigger a\n                    // lazy fetch during render.\n                    taskChild = spawnTaskForMissingData(newRouterStateChild);\n                }\n            } else {\n                // Either there's no existing Cache Node for this segment, or this\n                // segment doesn't exist in the old Router State tree. Switch to the\n                // \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        }\n        if (taskChild !== null) {\n            // Something changed in the child tree. Keep track of the child task.\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        lazyDataResolved: false\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead) {\n    // Create a task that will later be fulfilled by data from the server.\n    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        children: null\n    };\n}\nfunction spawnTaskForMissingData(routerState) {\n    // Create a task for a new subtree that wasn't prefetched by the server.\n    // This shouldn't really ever happen but it's here just in case the Seed Data\n    // Tree and the Router State Tree disagree unexpectedly.\n    const pendingCacheNode = createPendingCacheNode(routerState, null, null);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((response)=>{\n        const flightData = response[0];\n        for (const flightDataPath of flightData){\n            const segmentPath = flightDataPath.slice(0, -3);\n            const serverRouterState = flightDataPath[flightDataPath.length - 3];\n            const dynamicData = flightDataPath[flightDataPath.length - 2];\n            const dynamicHead = flightDataPath[flightDataPath.length - 1];\n            if (typeof segmentPath === \"string\") {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Null this out to indicate that the task is complete.\n            task.node = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : null,\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        lazyDataResolved: false\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[2];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Null this out to indicate that the task is complete.\n    task.node = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch  data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === \"pending\";\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        lazyDataResolved: false\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = \"pending\";\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === \"pending\") {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = \"fulfilled\";\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === \"pending\") {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = \"rejected\";\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Bwci1uYXZpZ2F0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUEybkJnQkEsV0FBUztlQUFUQTs7SUFuVEFDLHlCQUF1QjtlQUF2QkE7O0lBeFFBQyw2QkFBMkI7ZUFBM0JBOztJQXVvQkFDLHNDQUFvQztlQUFwQ0E7OztxQ0F6ckJUOzJDQUNzQjtrREFDUTtBQWdEOUIsU0FBU0QsNEJBQ2RFLFlBQXVCLEVBQ3ZCQyxjQUFpQyxFQUNqQ0MsY0FBaUMsRUFDakNDLFlBQStCLEVBQy9CQyxZQUE2QjtJQUU3QiwwREFBMEQ7SUFDMUQsTUFBTUMseUJBQXlCSixjQUFjLENBQUMsRUFBRTtJQUNoRCxNQUFNSyx5QkFBeUJKLGNBQWMsQ0FBQyxFQUFFO0lBQ2hELE1BQU1LLHVCQUF1QkosWUFBWSxDQUFDLEVBQUU7SUFFNUMsTUFBTUssb0JBQW9CUixhQUFhUyxjQUFjO0lBRXJELDJFQUEyRTtJQUMzRSxnQkFBZ0I7SUFDaEIsMEVBQTBFO0lBQzFFLDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSx1RUFBdUU7SUFDdkUseUVBQXlFO0lBQ3pFLHdFQUF3RTtJQUN4RSwrQkFBK0I7SUFDL0IsTUFBTUMseUJBQXlCLElBQUlDLElBQUlIO0lBRXZDLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM3RSxtQkFBbUI7SUFDbkIsSUFBSUksNkJBRUEsQ0FBQztJQUNMLElBQUlDLGVBQWU7SUFDbkIsSUFBSyxJQUFJQyxvQkFBb0JSLHVCQUF3QjtRQUNuRCxNQUFNUyxzQkFDSlQsc0JBQXNCLENBQUNRLGlCQUFpQjtRQUMxQyxNQUFNRSxzQkFDSlgsc0JBQXNCLENBQUNTLGlCQUFpQjtRQUMxQyxNQUFNRyxxQkFBcUJULGtCQUFrQlUsR0FB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QUFXLEdBQUc7UUFDNURFLFNBQVNpRSxvQkFBb0I1RyxhQUFhMkMsT0FBTyxHQUFHO1FBRXBELGtEQUFrRDtRQUNsRGxDLGdCQUFnQmtHO1FBQ2hCL0Qsa0JBQWtCO0lBQ3BCO0FBQ0Y7QUFFQSxNQUFNa0UsV0FBV0M7QUE4QmpCLDhFQUE4RTtBQUM5RSxnRkFBZ0Y7QUFDaEYsOEVBQThFO0FBQzlFLG1FQUFtRTtBQUNuRSxTQUFTUixjQUFjUyxLQUFVO0lBQy9CLE9BQU9BLFNBQVNBLE1BQU1DLEdBQUcsS0FBS0g7QUFDaEM7QUFFQSxTQUFTdkI7SUFDUCxJQUFJaUI7SUFDSixJQUFJRTtJQUNKLE1BQU1RLGFBQWEsSUFBSUMsUUFBeUIsQ0FBQ0MsS0FBS0M7UUFDcERiLFVBQVVZO1FBQ1ZWLFNBQVNXO0lBQ1g7SUFDQUgsV0FBV0wsTUFBTSxHQUFHO0lBQ3BCSyxXQUFXVixPQUFPLEdBQUcsQ0FBQ1E7UUFDcEIsSUFBSUUsV0FBV0wsTUFBTSxLQUFLLFdBQVc7WUFDbkMsTUFBTVMsZUFBcUNKO1lBQzNDSSxhQUFhVCxNQUFNLEdBQUc7WUFDdEJTLGFBQWFOLEtBQUssR0FBR0E7WUFDckJSLFFBQVFRO1FBQ1Y7SUFDRjtJQUNBRSxXQUFXUixNQUFNLEdBQUcsQ0FBQ3ZDO1FBQ25CLElBQUkrQyxXQUFXTCxNQUFNLEtBQUssV0FBVztZQUNuQyxNQUFNVSxjQUFtQ0w7WUFDekNLLFlBQVlWLE1BQU0sR0FBRztZQUNyQlUsWUFBWUMsTUFBTSxHQUFHckQ7WUFDckJ1QyxPQUFPdkM7UUFDVDtJQUNGO0lBQ0ErQyxXQUFXRCxHQUFHLEdBQUdIO0lBQ2pCLE9BQU9JO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcHItbmF2aWdhdGlvbnMudHM/NmE1NiJdLCJuYW1lcyI6WyJhYm9ydFRhc2siLCJsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsIm9sZENhY2hlTm9kZSIsIm9sZFJvdXRlclN0YXRlIiwibmV3Um91dGVyU3RhdGUiLCJwcmVmZXRjaERhdGEiLCJwcmVmZXRjaEhlYWQiLCJvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwibmV3Um91dGVyU3RhdGVDaGlsZHJlbiIsInByZWZldGNoRGF0YUNoaWxkcmVuIiwib2xkUGFyYWxsZWxSb3V0ZXMiLCJwYXJhbGxlbFJvdXRlcyIsInByZWZldGNoUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbiIsInRhc2tDaGlsZHJlbiIsInBhcmFsbGVsUm91dGVLZXkiLCJuZXdSb3V0ZXJTdGF0ZUNoaWxkIiwib2xkUm91dGVyU3RhdGVDaGlsZCIsIm9sZFNlZ21lbnRNYXBDaGlsZCIsImdldCIsInByZWZldGNoRGF0YUNoaWxkIiwibmV3U2VnbWVudENoaWxkIiwibmV3U2VnbWVudEtleUNoaWxkIiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJvbGRTZWdtZW50Q2hpbGQiLCJ1bmRlZmluZWQiLCJvbGRDYWNoZU5vZGVDaGlsZCIsInRhc2tDaGlsZCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJzcGF3blBlbmRpbmdUYXNrIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInNwYXduUmV1c2VkVGFzayIsIm1hdGNoU2VnbWVudCIsInNwYXduVGFza0Zvck1pc3NpbmdEYXRhIiwic2V0IiwibmV3Q2FjaGVOb2RlQ2hpbGQiLCJub2RlIiwibmV3U2VnbWVudE1hcENoaWxkIiwicm91dGUiLCJuZXdDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsImxvYWRpbmciLCJsYXp5RGF0YVJlc29sdmVkIiwicGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbiIsImNoaWxkcmVuIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsInJvdXRlclN0YXRlIiwicGVuZGluZ0NhY2hlTm9kZSIsImNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUiLCJyZXVzZWRSb3V0ZXJTdGF0ZSIsInRhc2siLCJyZXNwb25zZVByb21pc2UiLCJ0aGVuIiwicmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJzZWdtZW50UGF0aCIsInNsaWNlIiwic2VydmVyUm91dGVyU3RhdGUiLCJsZW5ndGgiLCJkeW5hbWljRGF0YSIsImR5bmFtaWNIZWFkIiwid3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayIsImVycm9yIiwicm9vdFRhc2siLCJpIiwic2VnbWVudCIsInRhc2tTZWdtZW50IiwiZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkIiwidGFza05vZGUiLCJmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlIiwic2VydmVyQ2hpbGRyZW4iLCJkeW5hbWljRGF0YUNoaWxkcmVuIiwic2VydmVyUm91dGVyU3RhdGVDaGlsZCIsImR5bmFtaWNEYXRhQ2hpbGQiLCJyb3V0ZXJTdGF0ZUNoaWxkcmVuIiwicm91dGVyU3RhdGVDaGlsZCIsInNlZ21lbnRDaGlsZCIsInNlZ21lbnRLZXlDaGlsZCIsImlzTGVhZlNlZ21lbnQiLCJzaXplIiwibWF5YmVQcmVmZXRjaFJzYyIsIm1heWJlUHJlZmV0Y2hMb2FkaW5nIiwiY3JlYXRlRGVmZXJyZWRSc2MiLCJjYWNoZU5vZGUiLCJ0YXNrU3RhdGUiLCJzZXJ2ZXJTdGF0ZSIsInRhc2tTdGF0ZUNoaWxkcmVuIiwic2VydmVyU3RhdGVDaGlsZHJlbiIsImRhdGFDaGlsZHJlbiIsInRhc2tTdGF0ZUNoaWxkIiwic2VydmVyU3RhdGVDaGlsZCIsImRhdGFDaGlsZCIsInNlZ21lbnRNYXBDaGlsZCIsInRhc2tTZWdtZW50Q2hpbGQiLCJ0YXNrU2VnbWVudEtleUNoaWxkIiwiY2FjaGVOb2RlQ2hpbGQiLCJhYm9ydFBlbmRpbmdDYWNoZU5vZGUiLCJkeW5hbWljU2VnbWVudERhdGEiLCJpc0RlZmVycmVkUnNjIiwicmVzb2x2ZSIsInZhbHVlcyIsInJlamVjdCIsIm5ld1BhcmFsbGVsUm91dGVzIiwic2hvdWxkVXNlUHJlZmV0Y2giLCJzdGF0dXMiLCJERUZFUlJFRCIsIlN5bWJvbCIsInZhbHVlIiwidGFnIiwicGVuZGluZ1JzYyIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJmdWxmaWxsZWRSc2MiLCJyZWplY3RlZFJzYyIsInJlYXNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n"))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchCacheEntryForInitialLoad: function() {\n        return createPrefetchCacheEntryForInitialLoad;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to \'/\'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKey(url, nextUrl) {\n    const pathnameFromUrl = (0, _createhreffromurl.createHrefFromUrl)(url, false);\n    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n    if (nextUrl) {\n        return nextUrl + "%" + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;\n    let existingCacheEntry = undefined;\n    // We first check if there\'s a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);\n    const interceptionData = prefetchCache.get(interceptionCacheKey);\n    if (interceptionData) {\n        existingCacheEntry = interceptionData;\n    } else {\n        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n        const prefetchCacheKey = createPrefetchCacheKey(url);\n        const prefetchData = prefetchCache.get(prefetchCacheKey);\n        if (prefetchData) {\n            existingCacheEntry = prefetchData;\n        }\n    }\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is "full" and the current cache entry wasn\'t, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            return createLazyPrefetchEntry({\n                tree,\n                url,\n                buildId,\n                nextUrl,\n                prefetchCache,\n                // If we didn\'t get an explicit prefetch kind, we want to set a temporary kind\n                // rather than assuming the same intent as the previous entry, to be consistent with how we\n                // lazily create prefetch entries when intent is left unspecified.\n                kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn\'t have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We\'ve determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn\'t return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        kind: kind || // in dev, there\'s never gonna be a prefetch entry so we want to prefetch here\n        ( true ? _routerreducertypes.PrefetchKind.AUTO : 0)\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don\'t have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache } = param;\n    const existingCacheKey = createPrefetchCacheKey(url);\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn\'t an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, nextUrl);\n    prefetchCache.set(newCacheKey, existingCacheEntry);\n    prefetchCache.delete(existingCacheKey);\n}\nfunction createPrefetchCacheEntryForInitialLoad(param) {\n    let { nextUrl, tree, prefetchCache, url, kind, data } = param;\n    const [, , , intercept] = data;\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            const [, , , intercepted] = prefetchResponse;\n            if (intercepted) {\n                prefixExistingPrefetchCacheEntry({\n                    url,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 30 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number("30") * 1000;\nconst STATIC_STALETIME_MS = Number("300") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For "auto" prefetching, we\'ll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a "lazy fetch" for the full data.\n    if (kind === "auto") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for "full" prefetching, we\'ll re-use the cache entry data for up to `static` staletime window.\n    if (kind === "full") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQW1KZ0JBLHdDQUFzQztlQUF0Q0E7O0lBNUdBQywrQkFBNkI7ZUFBN0JBOztJQWlNQUMsb0JBQWtCO2VBQWxCQTs7OytDQXhPa0I7aURBSTNCO2dEQU1BOzZDQUN1QjtBQUU5Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyx1QkFBdUJDLEdBQVEsRUFBRUMsT0FBdUI7SUFDL0QsTUFBTUMsa0JBQWtCQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQ3ZDSCxLQUVBO0lBR0YsK0ZBQStGO0lBQy9GLElBQUlDLFNBQVM7UUFDWCxPQUFPQSxVQUFXLE1BQUdDO0lBQ3ZCO0lBRUEsT0FBT0E7QUFDVDtBQU1PLFNBQVNMLDhCQUE4Qk8sS0FhN0M7SUFiNkMsTUFDNUNKLEdBQUcsRUFDSEMsT0FBTyxFQUNQSSxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsYUFBYSxFQUNiQyxJQUFJLEVBT0wsR0FiNkNKO0lBYzVDLElBQUlLLHFCQUFxREM7SUFDekQsOEVBQThFO0lBQzlFLGtKQUFrSjtJQUNsSixpSUFBaUk7SUFDakksTUFBTUMsdUJBQXVCWix1QkFBdUJDLEtBQUtDO0lBQ3pELE1BQU1XLG1CQUFtQkwsY0FBY00sR0FBRyxDQUFDRjtJQUUzQyxJQUFJQyxrQkFBa0I7UUFDcEJILHFCQUFxQkc7SUFDdkIsT0FBTztRQUNMLDJHQUEyRztRQUMzRyxNQUFNRSxtQkFBbUJmLHVCQUF1QkM7UUFDaEQsTUFBTWUsZUFBZVIsY0FBY00sR0FBRyxDQUFDQztRQUN2QyxJQUFJQyxjQUFjO1lBQ2hCTixxQkFBcUJNO1FBQ3ZCO0lBQ0Y7SUFFQSxJQUFJTixvQkFBb0I7UUFDdEIsMERBQTBEO1FBQzFEQSxtQkFBbUJPLE1BQU0sR0FBR0MsNEJBQTRCUjtRQUV4RCwrREFBK0Q7UUFDL0QscUhBQXFIO1FBQ3JILE1BQU1TLHlCQUNKVCxtQkFBbUJELElBQUksS0FBS1csb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxJQUM3Q1osU0FBU1csb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSTtRQUU1QixJQUFJRix3QkFBd0I7WUFDMUIsT0FBT0csd0JBQXdCO2dCQUM3QmhCO2dCQUNBTDtnQkFDQU07Z0JBQ0FMO2dCQUNBTTtnQkFDQSw4RUFBOEU7Z0JBQzlFLDJGQUEyRjtnQkFDM0Ysa0VBQWtFO2dCQUNsRUMsTUFBTUEsUUFBQUEsT0FBQUEsT0FBUVcsb0JBQUFBLFlBQVksQ0FBQ0csU0FBUztZQUN0QztRQUNGO1FBRUEsdUhBQXVIO1FBQ3ZILDRJQUE0STtRQUM1SSxJQUFJZCxRQUFRQyxtQkFBbUJELElBQUksS0FBS1csb0JBQUFBLFlBQVksQ0FBQ0csU0FBUyxFQUFFO1lBQzlEYixtQkFBbUJELElBQUksR0FBR0E7UUFDNUI7UUFFQSxxRkFBcUY7UUFDckYsT0FBT0M7SUFDVDtJQUVBLGtEQUFrRDtJQUNsRCxPQUFPWSx3QkFBd0I7UUFDN0JoQjtRQUNBTDtRQUNBTTtRQUNBTDtRQUNBTTtRQUNBQyxNQUNFQSxRQUNBLDhFQUE4RTtRQUM3RWUsQ0FBQUEsS0FBeUIsR0FDdEJKLG9CQUFBQSxZQUFZLENBQUNLLElBQUksR0FDakJMLENBQXNCO0lBQzlCO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTTSxpQ0FBaUNyQixLQU16QztJQU55QyxNQUN4Q0osR0FBRyxFQUNIQyxPQUFPLEVBQ1BNLGFBQWEsRUFHZCxHQU55Q0g7SUFPeEMsTUFBTXNCLG1CQUFtQjNCLHVCQUF1QkM7SUFDaEQsTUFBTVMscUJBQXFCRixjQUFjTSxHQUFHLENBQUNhO0lBQzdDLElBQUksQ0FBQ2pCLG9CQUFvQjtRQUN2Qix5Q0FBeUM7UUFDekM7SUFDRjtJQUVBLE1BQU1rQixjQUFjNUIsdUJBQXVCQyxLQUFLQztJQUNoRE0sY0FBY3FCLEdBQUcsQ0FBQ0QsYUFBYWxCO0lBQy9CRixjQUFjc0IsTUFBTSxDQUFDSDtBQUN2QjtBQUtPLFNBQVM5Qix1Q0FBdUNRLEtBV3REO0lBWHNELE1BQ3JESCxPQUFPLEVBQ1BJLElBQUksRUFDSkUsYUFBYSxFQUNiUCxHQUFHLEVBQ0hRLElBQUksRUFDSnNCLElBQUksRUFLTCxHQVhzRDFCO0lBWXJELE1BQU0sT0FBTzJCLFVBQVUsR0FBR0Q7SUFDMUIscUdBQXFHO0lBQ3JHLE1BQU1oQixtQkFBbUJpQixZQUNyQmhDLHVCQUF1QkMsS0FBS0MsV0FDNUJGLHVCQUF1QkM7SUFFM0IsTUFBTWdDLGdCQUFnQjtRQUNwQkMsc0JBQXNCNUI7UUFDdEJ5QixNQUFNSSxRQUFRQyxPQUFPLENBQUNMO1FBQ3RCdEI7UUFDQTRCLGNBQWNDLEtBQUtDLEdBQUc7UUFDdEJDLGNBQWNGLEtBQUtDLEdBQUc7UUFDdEJFLEtBQUsxQjtRQUNMRSxRQUFReUIsb0JBQUFBLHdCQUF3QixDQUFDQyxLQUFLO0lBQ3hDO0lBRUFuQyxjQUFjcUIsR0FBRyxDQUFDZCxrQkFBa0JrQjtJQUVwQyxPQUFPQTtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTWCx3QkFBd0JqQixLQWFoQztJQWJnQyxNQUMvQkosR0FBRyxFQUNIUSxJQUFJLEVBQ0pILElBQUksRUFDSkosT0FBTyxFQUNQSyxPQUFPLEVBQ1BDLGFBQWEsRUFPZCxHQWJnQ0g7SUFjL0IsTUFBTVUsbUJBQW1CZix1QkFBdUJDO0lBRWhELHVFQUF1RTtJQUN2RSw2RkFBNkY7SUFDN0YsTUFBTThCLE9BQU9hLGlCQUFBQSxhQUFhLENBQUNDLE9BQU8sQ0FBQyxJQUNqQ0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDN0MsS0FBS0ssTUFBTUosU0FBU0ssU0FBU0UsTUFBTXNDLElBQUksQ0FDekQsQ0FBQ0M7WUFDQywrRkFBK0Y7WUFDL0Ysd0RBQXdEO1lBQ3hELGtFQUFrRTtZQUNsRSxNQUFNLE9BQU9DLFlBQVksR0FBR0Q7WUFDNUIsSUFBSUMsYUFBYTtnQkFDZnZCLGlDQUFpQztvQkFBRXpCO29CQUFLQztvQkFBU007Z0JBQWM7WUFDakU7WUFFQSxPQUFPd0M7UUFDVDtJQUlKLE1BQU1mLGdCQUFnQjtRQUNwQkMsc0JBQXNCNUI7UUFDdEJ5QjtRQUNBdEI7UUFDQTRCLGNBQWNDLEtBQUtDLEdBQUc7UUFDdEJDLGNBQWM7UUFDZEMsS0FBSzFCO1FBQ0xFLFFBQVF5QixvQkFBQUEsd0JBQXdCLENBQUNDLEtBQUs7SUFDeEM7SUFFQW5DLGNBQWNxQixHQUFHLENBQUNkLGtCQUFrQmtCO0lBRXBDLE9BQU9BO0FBQ1Q7QUFFTyxTQUFTbEMsbUJBQ2RTLGFBQW9EO0lBRXBELEtBQUssTUFBTSxDQUFDMEMsTUFBTUMsbUJBQW1CLElBQUkzQyxjQUFlO1FBQ3RELElBQ0VVLDRCQUE0QmlDLHdCQUM1QlQsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPLEVBQ2hDO1lBQ0E1QyxjQUFjc0IsTUFBTSxDQUFDb0I7UUFDdkI7SUFDRjtBQUNGO0FBRUEsOEZBQThGO0FBQzlGLDJEQUEyRDtBQUMzRCxNQUFNRyx1QkFDSkMsT0FBTzlCLElBQWtELElBQUk7QUFFL0QsTUFBTWlDLHNCQUNKSCxPQUFPOUIsS0FBaUQsSUFBSTtBQUU5RCxTQUFTTiw0QkFBNEJiLEtBSWhCO0lBSmdCLE1BQ25DSSxJQUFJLEVBQ0o0QixZQUFZLEVBQ1pHLFlBQVksRUFDTyxHQUpnQm5DO0lBS25DLGdGQUFnRjtJQUNoRixJQUFJaUMsS0FBS0MsR0FBRyxLQUFLLENBQUNDLGdCQUFBQSxPQUFBQSxlQUFnQkgsWUFBQUEsSUFBZ0JnQixzQkFBc0I7UUFDdEUsT0FBT2IsZUFDSEUsb0JBQUFBLHdCQUF3QixDQUFDaUIsUUFBUSxHQUNqQ2pCLG9CQUFBQSx3QkFBd0IsQ0FBQ0MsS0FBSztJQUNwQztJQUVBLHNHQUFzRztJQUN0Ryw0RUFBNEU7SUFDNUUsc0RBQXNEO0lBQ3RELElBQUlsQyxTQUFTLFFBQVE7UUFDbkIsSUFBSTZCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZW9CLHFCQUFxQjtZQUNuRCxPQUFPZixvQkFBQUEsd0JBQXdCLENBQUNrQixLQUFLO1FBQ3ZDO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsSUFBSW5ELFNBQVMsUUFBUTtRQUNuQixJQUFJNkIsS0FBS0MsR0FBRyxLQUFLRixlQUFlb0IscUJBQXFCO1lBQ25ELE9BQU9mLG9CQUFBQSx3QkFBd0IsQ0FBQ2lCLFFBQVE7UUFDMUM7SUFDRjtJQUVBLE9BQU9qQixvQkFBQUEsd0JBQXdCLENBQUNVLE9BQU87QUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcmVmZXRjaC1jYWNoZS11dGlscy50cz9iNjIxIl0sIm5hbWVzIjpbImNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeUZvckluaXRpYWxMb2FkIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5IiwidXJsIiwibmV4dFVybCIsInBhdGhuYW1lRnJvbVVybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicGFyYW0iLCJ0cmVlIiwiYnVpbGRJZCIsInByZWZldGNoQ2FjaGUiLCJraW5kIiwiZXhpc3RpbmdDYWNoZUVudHJ5IiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0aW9uQ2FjaGVLZXkiLCJpbnRlcmNlcHRpb25EYXRhIiwiZ2V0IiwicHJlZmV0Y2hDYWNoZUtleSIsInByZWZldGNoRGF0YSIsInN0YXR1cyIsImdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyIsInN3aXRjaGVkVG9GdWxsUHJlZmV0Y2giLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJURU1QT1JBUlkiLCJwcm9jZXNzIiwiQVVUTyIsInByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhpc3RpbmdDYWNoZUtleSIsIm5ld0NhY2hlS2V5Iiwic2V0IiwiZGVsZXRlIiwiZGF0YSIsImludGVyY2VwdCIsInByZWZldGNoRW50cnkiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJlZmV0Y2hUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RVc2VkVGltZSIsImtleSIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsImZyZXNoIiwicHJlZmV0Y2hRdWV1ZSIsImVucXVldWUiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidGhlbiIsInByZWZldGNoUmVzcG9uc2UiLCJpbnRlcmNlcHRlZCIsImhyZWYiLCJwcmVmZXRjaENhY2hlRW50cnkiLCJleHBpcmVkIiwiRFlOQU1JQ19TVEFMRVRJTUVfTVMiLCJOdW1iZXIiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FIiwicmV1c2FibGUiLCJzdGFsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "fastRefreshReducer", ({\n    enumerable: true,\n    get: function() {\n        return fastRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn\'t get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        state.tree[0],\n        state.tree[1],\n        state.tree[2],\n        "refetch"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("REFRESH FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction fastRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst fastRefreshReducer =  false ? 0 : fastRefreshReducerImpl;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fast-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2Zhc3QtcmVmcmVzaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0RBNEhhQTs7O2VBQUFBOzs7aURBNUh1QjsrQ0FDRjt5REFDVTt5REFDQTs2Q0FPVjsyQ0FDSjs2Q0FDRTt1Q0FFSzttREFDQzsrREFDWTtBQUVsRCx3RkFBd0Y7QUFDeEYsU0FBU0MsdUJBQ1BDLEtBQTJCLEVBQzNCQyxNQUF5QjtJQUV6QixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUNuQixNQUFNRSxVQUFtQixDQUFDO0lBQzFCLE1BQU1DLE9BQU9KLE1BQU1LLFlBQVk7SUFFL0JGLFFBQVFHLDBCQUEwQixHQUFHO0lBRXJDLE1BQU1DLFFBQW1CQyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7SUFDN0Msc0ZBQXNGO0lBQ3RGLHNIQUFzSDtJQUN0SCxNQUFNQyxpQkFBaUJDLENBQUFBLEdBQUFBLG1DQUFBQSxpQ0FBaUMsRUFBQ1YsTUFBTVcsSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDSixNQUFNSyxRQUFRLEdBQUdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFDbEMsSUFBSUMsSUFBSVYsTUFBTUYsU0FDZDtRQUFDRixNQUFNVyxJQUFJLENBQUMsRUFBRTtRQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtRQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtRQUFFO0tBQVUsRUFDeERGLGlCQUFpQlQsTUFBTWUsT0FBTyxHQUFHLE1BQ2pDZixNQUFNZ0IsT0FBTztJQUdmLE9BQU9ULE1BQU1LLFFBQVEsQ0FBQ0ssSUFBSSxDQUN4QixDQUFBQztZQUFDLENBQUNDLFlBQVlDLHFCQUFxQixHQUFBRjtRQUNqQyw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPQyxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnJCLE9BQ0FHLFNBQ0FnQixZQUNBbkIsTUFBTXNCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRGhCLE1BQU1LLFFBQVEsR0FBRztRQUVqQixJQUFJWSxjQUFjeEIsTUFBTVcsSUFBSTtRQUM1QixJQUFJYyxlQUFlekIsTUFBTU8sS0FBSztRQUU5QixLQUFLLE1BQU1tQixrQkFBa0JQLFdBQVk7WUFDdkMsb0ZBQW9GO1lBQ3BGLElBQUlPLGVBQWVDLE1BQU0sS0FBSyxHQUFHO2dCQUMvQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTzdCO1lBQ1Q7WUFFQSxtR0FBbUc7WUFDbkcsTUFBTSxDQUFDOEIsVUFBVSxHQUFHSjtZQUNwQixNQUFNSyxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQTJCLEVBRXpDO2dCQUFDO2FBQUcsRUFDSlIsYUFDQU0sV0FDQTlCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTBCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFxQixFQUFDakMsT0FBT0MsUUFBUTZCO1lBQzlDO1lBRUEsSUFBSUksQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUFDVixhQUFhTyxVQUFVO2dCQUNyRCxPQUFPVixDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCckIsT0FDQUcsU0FDQUMsTUFDQUosTUFBTXNCLE9BQU8sQ0FBQ0MsV0FBVztZQUU3QjtZQUVBLE1BQU1ZLDJCQUEyQmYsdUJBQzdCZ0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QmpCLFFBQVFFLFlBQVksR0FBRzhCO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFBQ2QsY0FBY2xCLE9BQU9tQjtZQUVyRCxJQUFJWSxTQUFTO2dCQUNYbkMsUUFBUUksS0FBSyxHQUFHQTtnQkFDaEJrQixlQUFlbEI7WUFDakI7WUFFQUosUUFBUXFDLFdBQVcsR0FBR1Q7WUFDdEI1QixRQUFRRSxZQUFZLEdBQUdEO1lBRXZCb0IsY0FBY087UUFDaEI7UUFDQSxPQUFPVSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUN6QyxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTMEMsdUJBQ1AxQyxLQUEyQixFQUMzQjJDLE9BQTBCO0lBRTFCLE9BQU8zQztBQUNUO0FBRU8sTUFBTUYscUJBQ1g4QyxNQUF5QixHQUNyQkYsQ0FBQUEsR0FDQTNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmFzdC1yZWZyZXNoLXJlZHVjZXIudHM/ZTViYiJdLCJuYW1lcyI6WyJmYXN0UmVmcmVzaFJlZHVjZXIiLCJmYXN0UmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsImN1cnJlbnRDYWNoZSIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImFwcGxpZWQiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiLCJmYXN0UmVmcmVzaFJlZHVjZXJOb29wIiwiX2FjdGlvbiIsInByb2Nlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "findHeadInCache", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, "");\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + "/" + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUlnQkE7OztlQUFBQTs7O2tEQUZxQjtBQUU5QixTQUFTQSxnQkFDZEMsS0FBZ0IsRUFDaEJDLGNBQW9DO0lBRXBDLE9BQU9DLG9CQUFvQkYsT0FBT0MsZ0JBQWdCO0FBQ3BEO0FBRUEsU0FBU0Msb0JBQ1BGLEtBQWdCLEVBQ2hCQyxjQUFvQyxFQUNwQ0UsU0FBaUI7SUFFakIsTUFBTUMsYUFBYUMsT0FBT0MsSUFBSSxDQUFDTCxnQkFBZ0JNLE1BQU0sS0FBSztJQUMxRCxJQUFJSCxZQUFZO1FBQ2QsMEVBQTBFO1FBQzFFLE9BQU87WUFBQ0o7WUFBT0c7U0FBVTtJQUMzQjtJQUNBLElBQUssTUFBTUssT0FBT1AsZUFBZ0I7UUFDaEMsTUFBTSxDQUFDUSxTQUFTQyxvQkFBb0IsR0FBR1QsY0FBYyxDQUFDTyxJQUFJO1FBQzFELE1BQU1HLGtCQUFrQlgsTUFBTUMsY0FBYyxDQUFDVyxHQUFHLENBQUNKO1FBQ2pELElBQUksQ0FBQ0csaUJBQWlCO1lBQ3BCO1FBQ0Y7UUFFQSxNQUFNRSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUNMO1FBRXRDLE1BQU1NLFlBQVlKLGdCQUFnQkMsR0FBRyxDQUFDQztRQUN0QyxJQUFJLENBQUNFLFdBQVc7WUFDZDtRQUNGO1FBRUEsTUFBTUMsT0FBT2Qsb0JBQ1hhLFdBQ0FMLHFCQUNBUCxZQUFZLE1BQU1VO1FBRXBCLElBQUlHLE1BQU07WUFDUixPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUudHM/OGJjZCJdLCJuYW1lcyI6WyJmaW5kSGVhZEluQ2FjaGUiLCJjYWNoZSIsInBhcmFsbGVsUm91dGVzIiwiZmluZEhlYWRJbkNhY2hlSW1wbCIsImtleVByZWZpeCIsImlzTGFzdEl0ZW0iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwia2V5Iiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJnZXQiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiY2FjaGVOb2RlIiwiaXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "getSegmentValue", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2dldC1zZWdtZW50LXZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBRWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxnQkFBZ0JDLE9BQWdCO0lBQzlDLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0E7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZS50cz9hYjhhIl0sIm5hbWVzIjpbImdldFNlZ21lbnRWYWx1ZSIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "hasInterceptionRouteInCurrentTree", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ "(app-pages-browser)/../node_modules/next/dist/server/future/helpers/interception-routes.js");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it\'s marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === "string" && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7cUVBR2dCQTs7O2VBQUFBOzs7Z0RBRjJCO0FBRXBDLFNBQVNBLGtDQUFrQ0MsS0FHOUI7SUFIOEIsS0FDaERDLFNBQ0FDLGVBQ2tCLEdBSDhCRjtJQUloRCx3R0FBd0c7SUFDeEcsSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssT0FBTztRQUMxRSxPQUFPO0lBQ1Q7SUFFQSxvRUFBb0U7SUFDcEUsSUFBSSxPQUFPQSxZQUFZLFlBQVlJLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0osVUFBVTtRQUN0RSxPQUFPO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSUMsZ0JBQWdCO1FBQ2xCLElBQUssTUFBTUksT0FBT0osZUFBZ0I7WUFDaEMsSUFBSUgsa0NBQWtDRyxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDMUQsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLnRzP2RmYzYiXSwibmFtZXMiOlsiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwicGFyYW0iLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ "(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === "") {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nconst navigateReducer =  false ? 0 : navigateReducer_noPPR;\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it\'s been running in production for a while.\nfunction navigateReducer_noPPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === "push";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv="refresh">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById("__next-page-redirect")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove \'\'\n            const flightSegmentPathWithLeadingEmpty = [\n                "",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can\'t be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                let applied = false;\n                if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we\'re navigating to, to support instant loading navigations\n                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                    // while copying over the `loading` for the segment that contains the page data.\n                    // We only do this on subsequent reads, as otherwise there\'d be no loading data to re-use.\n                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                    // since we re-used the stale cache\'s loading state & refreshed the data,\n                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                    prefetchValues.lastUsedTime = Date.now();\n                } else {\n                    applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                }\n                const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                if (hardNavigate) {\n                    // Copy rsc for the root node of the cache.\n                    cache.rsc = currentCache.rsc;\n                    cache.prefetchRsc = currentCache.prefetchRsc;\n                    (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                    // Ensure the existing cache value is used when the cache was not invalidated.\n                    mutable.cache = cache;\n                } else if (applied) {\n                    mutable.cache = cache;\n                    // If we applied the cache, we update the "current cache" value so any other\n                    // segments in the FlightDataPath will be able to reference the updated cache.\n                    currentCache = cache;\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn\'t be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n// This is the experimental PPR implementation. It\'s closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === "push";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride, _postponed] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv="refresh">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById("__next-page-redirect")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        // TODO: In practice, this is always a single item array. We probably\n        // aren\'t going to every send multiple segments, at least not in this\n        // format. So we could remove the extra wrapper for now until\n        // that settles.\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove \'\'\n            const flightSegmentPathWithLeadingEmpty = [\n                "",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can\'t be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                if (// will always send back a static response that\'s rendered from\n                // the root. If for some reason it doesn\'t, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via updateCacheNodeOnNavigation. The current structure is just\n                // an incremental step.\n                flightDataPath.length === 3) {\n                    const prefetchedTree = flightDataPath[0];\n                    const seedData = flightDataPath[1];\n                    const head = flightDataPath[2];\n                    const task = (0, _pprnavigations.updateCacheNodeOnNavigation)(currentCache, currentTree, prefetchedTree, seedData, head);\n                    if (task !== null && task.node !== null) {\n                        // We\'ve created a new Cache Node tree that contains a prefetched\n                        // version of the next page. This can be rendered instantly.\n                        // Use the tree computed by updateCacheNodeOnNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        // The prefetched tree has dynamic holes in it. We initiate a\n                        // dynamic request to fill them in.\n                        //\n                        // Do not block on the result. We\'ll immediately render the Cache\n                        // Node tree and suspend on the dynamic parts. When the request\n                        // comes in, we\'ll fill in missing data and ping React to\n                        // re-render. Unlike the lazy fetching model in the non-PPR\n                        // implementation, this is modeled as a single React update +\n                        // streaming, rather than multiple top-level updates. (However,\n                        // even in the new model, we\'ll still need to sometimes update the\n                        // root multiple times per navigation, like if the server sends us\n                        // a different response than we expected. For now, we revert back\n                        // to the lazy fetching mechanism in that case.)\n                        (0, _pprnavigations.listenForDynamicRequest)(task, (0, _fetchserverresponse.fetchServerResponse)(url, currentTree, state.nextUrl, state.buildId));\n                        mutable.cache = newCache;\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = prefetchedTree;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there\'s no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we\'re navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there\'d be no loading data to re-use.\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache\'s loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the "current cache" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn\'t be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaUNnQkEsbUJBQWlCO2VBQWpCQTs7SUFxRUhDLGlCQUFlO2VBQWZBOzs7aURBakd1QjsrQ0FDRjttRUFDb0I7eURBQ1Y7Z0RBQ1Q7eURBQ1M7Z0RBT3JDOzJDQUN1Qjs2Q0FDRTs2Q0FDRjt1Q0FDTztxQ0FDRDs0Q0FJN0I7Z0RBSUE7OERBQzBDO0FBRTFDLFNBQVNELGtCQUNkRSxLQUEyQixFQUMzQkMsT0FBZ0IsRUFDaEJDLEdBQVcsRUFDWEMsV0FBb0I7SUFFcEJGLFFBQVFHLGFBQWEsR0FBRztJQUN4QkgsUUFBUUksWUFBWSxHQUFHSDtJQUN2QkQsUUFBUUUsV0FBVyxHQUFHQTtJQUN0QkYsUUFBUUssa0JBQWtCLEdBQUdDO0lBRTdCLE9BQU9DLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ1IsT0FBT0M7QUFDOUI7QUFFQSxTQUFTUSwwQkFDUEMsaUJBQW9DO0lBRXBDLE1BQU1DLFdBQWdDLEVBQUU7SUFDeEMsTUFBTSxDQUFDQyxTQUFTQyxlQUFlLEdBQUdIO0lBRWxDLElBQUlJLE9BQU9DLElBQUksQ0FBQ0YsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztRQUM1QyxPQUFPO1lBQUM7Z0JBQUNKO2FBQVE7U0FBQztJQUNwQjtJQUVBLEtBQUssTUFBTSxDQUFDSyxrQkFBa0JDLGNBQWMsSUFBSUosT0FBT0ssT0FBTyxDQUM1RE4sZ0JBQ0M7UUFDRCxLQUFLLE1BQU1PLGdCQUFnQlgsMEJBQTBCUyxlQUFnQjtZQUNuRSxtRUFBbUU7WUFDbkUsSUFBSU4sWUFBWSxJQUFJO2dCQUNsQkQsU0FBU1UsSUFBSSxDQUFDO29CQUFDSjt1QkFBcUJHO2lCQUFhO1lBQ25ELE9BQU87Z0JBQ0xULFNBQVNVLElBQUksQ0FBQztvQkFB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QUFNLEdBQUcsRUFBRSxLQUN2RDBFLFNBQUFBLG1CQUFtQixFQUNuQjt3QkFDQXBGLG1CQUFtQmUsSUFBSSxDQUFDb0U7b0JBQzFCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBeEYsUUFBUTBGLFdBQVcsR0FBR3BCO1FBQ3RCdEUsUUFBUUksWUFBWSxHQUFHMkQsdUJBQ25CakIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDaUIsd0JBQ2xCbEI7UUFDSjdDLFFBQVFFLFdBQVcsR0FBR0E7UUFDdEJGLFFBQVFLLGtCQUFrQixHQUFHQTtRQUM3QkwsUUFBUTJGLFlBQVksR0FBRy9DO1FBQ3ZCNUMsUUFBUTJDLFlBQVksR0FBR0E7UUFFdkIsT0FBT3BDLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ1IsT0FBT0M7SUFDOUIsR0FDQSxJQUFNRDtBQUVWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci50cz8xZmViIl0sIm5hbWVzIjpbImhhbmRsZUV4dGVybmFsVXJsIiwibmF2aWdhdGVSZWR1Y2VyIiwic3RhdGUiLCJtdXRhYmxlIiwidXJsIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwidW5kZWZpbmVkIiwiaGFuZGxlTXV0YWJsZSIsImdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2giLCJmbGlnaHRSb3V0ZXJQYXRjaCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJwYXJhbGxlbFJvdXRlIiwiZW50cmllcyIsImNoaWxkU2VnbWVudCIsInB1c2giLCJ0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzIiwibmV3Q2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsImFwcGxpZWRQYXRjaCIsInJzYyIsInByZWZldGNoUnNjIiwibG9hZGluZyIsIk1hcCIsInNlZ21lbnRQYXRoc1RvRmlsbCIsIm1hcCIsInNlZ21lbnRQYXRocyIsImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJuYXZpZ2F0ZVJlZHVjZXJfUFBSIiwibmF2aWdhdGVSZWR1Y2VyX25vUFBSIiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsIm5hdmlnYXRlVHlwZSIsInNob3VsZFNjcm9sbCIsImhhc2giLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJ0b1N0cmluZyIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwidHJlZSIsImJ1aWxkSWQiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsImRhdGEiLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsInRoZW4iLCJwYXJhbSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjdXJyZW50VHJlZSIsImNhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJzbGljZSIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInBhdGNoZWRUcmVlIiwiaGFzaEZyYWdtZW50IiwiX3Bvc3Rwb25lZCIsInByZWZldGNoZWRUcmVlIiwic2VlZERhdGEiLCJoZWFkIiwidGFzayIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsIm5vZGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJyb3V0ZSIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js");\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ "(app-pages-browser)/../node_modules/next/dist/client/components/promise-queue.js");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nfunction prefetchReducer(state, action) {\n    // let\'s prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    url.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        buildId: state.buildId\n    });\n    return state;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBWWFBLGVBQWE7ZUFBYkE7O0lBRUdDLGlCQUFlO2VBQWZBOzs7OENBVHFCOzBDQUNSO2dEQUl0QjtBQUVBLE1BQU1ELGdCQUFnQixJQUFJRSxjQUFBQSxZQUFZLENBQUM7QUFFdkMsU0FBU0QsZ0JBQ2RFLEtBQTJCLEVBQzNCQyxNQUFzQjtJQUV0Qiw0REFBNEQ7SUFDNURDLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBa0IsRUFBQ0YsTUFBTUcsYUFBYTtJQUV0QyxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHSDtJQUNoQkcsSUFBSUMsWUFBWSxDQUFDQyxNQUFNLENBQUNDLGtCQUFBQSxvQkFBb0I7SUFFNUNDLENBQUFBLEdBQUFBLG9CQUFBQSw2QkFBNkIsRUFBQztRQUM1Qko7UUFDQUssU0FBU1QsTUFBTVMsT0FBTztRQUN0Qk4sZUFBZUgsTUFBTUcsYUFBYTtRQUNsQ08sTUFBTVQsT0FBT1MsSUFBSTtRQUNqQkMsTUFBTVgsTUFBTVcsSUFBSTtRQUNoQkMsU0FBU1osTUFBTVksT0FBTztJQUN4QjtJQUVBLE9BQU9aO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLnRzPzQ1YmYiXSwibmFtZXMiOlsicHJlZmV0Y2hRdWV1ZSIsInByZWZldGNoUmVkdWNlciIsIlByb21pc2VRdWV1ZSIsInN0YXRlIiwiYWN0aW9uIiwicHJ1bmVQcmVmZXRjaENhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInVybCIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJidWlsZElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "refreshReducer", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn\'t get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        currentTree[0],\n        currentTree[1],\n        currentTree[2],\n        "refetch"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then(async (param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("REFRESH FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[2];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                mutable.prefetchCache = new Map();\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQW1CZ0JBOzs7ZUFBQUE7OztpREFuQm9COytDQUNGO3lEQUNVO3lEQUNBOzZDQU9WOzJDQUNKOzJEQUVnQjt1Q0FDVDttREFDQzsrREFDWTs2REFDRjtBQUV6QyxTQUFTQSxlQUNkQyxLQUEyQixFQUMzQkMsTUFBcUI7SUFFckIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CLElBQUlDLGNBQWNOLE1BQU1PLElBQUk7SUFFNUJKLFFBQVFLLDBCQUEwQixHQUFHO0lBRXJDLE1BQU1DLFFBQW1CQyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7SUFFN0Msc0ZBQXNGO0lBQ3RGLHNIQUFzSDtJQUN0SCxNQUFNQyxpQkFBaUJDLENBQUFBLEdBQUFBLG1DQUFBQSxpQ0FBaUMsRUFBQ1osTUFBTU8sSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDRSxNQUFNSSxRQUFRLEdBQUdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFDbEMsSUFBSUMsSUFBSVgsTUFBTUYsU0FDZDtRQUFDSSxXQUFXLENBQUMsRUFBRTtRQUFFQSxXQUFXLENBQUMsRUFBRTtRQUFFQSxXQUFXLENBQUMsRUFBRTtRQUFFO0tBQVUsRUFDM0RLLGlCQUFpQlgsTUFBTWdCLE9BQU8sR0FBRyxNQUNqQ2hCLE1BQU1pQixPQUFPO0lBR2YsT0FBT1IsTUFBTUksUUFBUSxDQUFDSyxJQUFJLENBQ3hCLE9BQUFDO1lBQU8sQ0FBQ0MsWUFBWUMscUJBQXFCLEdBQUFGO1FBQ3ZDLDREQUE0RDtRQUM1RCxJQUFJLE9BQU9DLGVBQWUsVUFBVTtZQUNsQyxPQUFPRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCdEIsT0FDQUcsU0FDQWlCLFlBQ0FwQixNQUFNdUIsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsK0RBQStEO1FBQy9EZixNQUFNSSxRQUFRLEdBQUc7UUFFakIsS0FBSyxNQUFNWSxrQkFBa0JMLFdBQVk7WUFDdkMsb0ZBQW9GO1lBQ3BGLElBQUlLLGVBQWVDLE1BQU0sS0FBSyxHQUFHO2dCQUMvQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTzVCO1lBQ1Q7WUFFQSxtR0FBbUc7WUFDbkcsTUFBTSxDQUFDNkIsVUFBVSxHQUFHSjtZQUNwQixNQUFNSyxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQTJCLEVBRXpDO2dCQUFDO2FBQUcsRUFDSnpCLGFBQ0F1QixXQUNBN0IsTUFBTUssWUFBWTtZQUdwQixJQUFJeUIsWUFBWSxNQUFNO2dCQUNwQixPQUFPRSxDQUFBQSxHQUFBQSx1QkFBQUEscUJBQXFCLEVBQUNoQyxPQUFPQyxRQUFRNEI7WUFDOUM7WUFFQSxJQUFJSSxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQTJCLEVBQUMzQixhQUFhd0IsVUFBVTtnQkFDckQsT0FBT1IsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnRCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU11QixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNVSwyQkFBMkJiLHVCQUM3QmMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDZCx3QkFDbEJlO1lBRUosSUFBSWYsc0JBQXNCO2dCQUN4QmxCLFFBQVFFLFlBQVksR0FBRzZCO1lBQ3pCO1lBRUEsMERBQTBEO1lBQzFELE1BQU0sQ0FBQ0csbUJBQW1CQyxLQUFLLEdBQUdiLGVBQWVjLEtBQUssQ0FBQyxDQUFDO1lBRXhELDhGQUE4RjtZQUM5RixJQUFJRixzQkFBc0IsTUFBTTtnQkFDOUIsTUFBTUcsTUFBTUgsaUJBQWlCLENBQUMsRUFBRTtnQkFDaEM1QixNQUFNK0IsR0FBRyxHQUFHQTtnQkFDWi9CLE1BQU1nQyxXQUFXLEdBQUc7Z0JBQ3BCQyxDQUFBQSxHQUFBQSwrQkFBQUEsNkJBQTZCLEVBQzNCakMsT0FFQTJCLFdBQ0FQLFdBQ0FRLG1CQUNBQztnQkFFRm5DLFFBQVF3QyxhQUFhLEdBQUcsSUFBSUM7WUFDOUI7WUFFQSxNQUFNQyxDQUFBQSxHQUFBQSxpQ0FBQUEsK0JBQStCLEVBQUM7Z0JBQ3BDN0M7Z0JBQ0E4QyxhQUFhaEI7Z0JBQ2JpQixjQUFjdEM7Z0JBQ2RFO2dCQUNBTixjQUFjRixRQUFRRSxZQUFZLElBQUlMLE1BQU1LLFlBQVk7WUFDMUQ7WUFFQUYsUUFBUU0sS0FBSyxHQUFHQTtZQUNoQk4sUUFBUTZDLFdBQVcsR0FBR2xCO1lBQ3RCM0IsUUFBUUUsWUFBWSxHQUFHRDtZQUV2QkUsY0FBY3dCO1FBQ2hCO1FBRUEsT0FBT21CLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ2pELE9BQU9HO0lBQzlCLEdBQ0EsSUFBTUg7QUFFViIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci50cz9iNWU3Il0sIm5hbWVzIjpbInJlZnJlc2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImN1cnJlbnRUcmVlIiwidHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibmV4dFVybCIsImJ1aWxkSWQiLCJ0aGVuIiwicGFyYW0iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsInNsaWNlIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "restoreReducer", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it\'s possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we\'ll continue to use the existing tree so the router doesn\'t get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        buildId: state.buildId,\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVNnQkE7OztlQUFBQTs7OytDQVRrQjtnREFNZTs0Q0FDSTtBQUU5QyxTQUFTQSxlQUNkQyxLQUEyQixFQUMzQkMsTUFBcUI7SUFFckIsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHRjtJQUN0QixNQUFNRyxPQUFPQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQUNIO0lBQy9CLDBFQUEwRTtJQUMxRSw0RkFBNEY7SUFDNUYsZ0dBQWdHO0lBQ2hHLDZGQUE2RjtJQUM3Riw4REFBOEQ7SUFDOUQseUdBQXlHO0lBQ3pHLE1BQU1JLGdCQUFnQkgsUUFBUUgsTUFBTUcsSUFBSTtJQUV4QyxNQUFNSSxXQUFXUCxNQUFNUSxLQUFLO0lBQzVCLE1BQU1DLFdBQVdDLE1BQXNCLEdBS25DRywyREFGMkQ7SUFDM0QsMkJBQTJCO0lBQzNCQSxDQUErQ1AsR0FDL0NDO1FBaUJPTztJQWZYLE9BQU87UUFDTEMsU0FBU2YsTUFBTWUsT0FBTztRQUN0QixvQkFBb0I7UUFDcEJDLGNBQWNaO1FBQ2RhLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsNkZBQTZGO1lBQzdGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CckIsTUFBTXFCLGlCQUFpQjtRQUMxQ2IsT0FBT0M7UUFDUGEsZUFBZXRCLE1BQU1zQixhQUFhO1FBQ2xDLHdCQUF3QjtRQUN4Qm5CLE1BQU1HO1FBQ05pQixTQUFTVCxDQUFBQSxvQ0FBQUEsQ0FBQUEsR0FBQUEsb0JBQUFBLGdDQUFnQyxFQUFDUixjQUFBQSxLQUFBQSxPQUFqQ1Esb0NBQW1EWixJQUFJc0IsUUFBUTtJQUMxRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLnRzP2FlNTYiXSwibmFtZXMiOlsicmVzdG9yZVJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInVybCIsInRyZWUiLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ0cmVlVG9SZXN0b3JlIiwib2xkQ2FjaGUiLCJjYWNoZSIsIm5ld0NhY2hlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJ1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24iLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsImJ1aWxkSWQiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByZWZldGNoQ2FjaGUiLCJuZXh0VXJsIiwicGF0aG5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "serverActionReducer", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ "(app-pages-browser)/../node_modules/next/dist/client/app-call-server.js");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js");\nconst _addbasepath = __webpack_require__(/*! ../../../add-base-path */ "(app-pages-browser)/../node_modules/next/dist/client/add-base-path.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from \'react-server-dom-webpack/client\'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from \'react-server-dom-webpack/client\'\nconst { createFromFetch, encodeReply } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ "(app-pages-browser)/../node_modules/next/dist/compiled/react-server-dom-webpack/client.js");\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const body = await encodeReply(actionArgs);\n    const res = await fetch("", {\n        method: "POST",\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const location = res.headers.get("x-action-redirect");\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get("x-action-revalidated") || "[[],0,0]");\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? new URL((0, _addbasepath.addBasePath)(location), new URL(state.canonicalUrl, window.location.href)) : undefined;\n    let isFlightResponse = res.headers.get("content-type") === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n    if (isFlightResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            const [, actionFlightData] = response != null ? response : [];\n            return {\n                actionFlightData: actionFlightData,\n                redirectLocation,\n                revalidatedParts\n            };\n        }\n        // otherwise it\'s a tuple of [actionResult, actionFlightData]\n        const [actionResult, [, actionFlightData]] = response != null ? response : [];\n        return {\n            actionResult,\n            actionFlightData,\n            redirectLocation,\n            revalidatedParts\n        };\n    }\n    return {\n        redirectLocation,\n        revalidatedParts\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);\n    return mutable.inFlightServerAction.then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation } = param;\n        // Make sure the redirection is a push instead of a replace.\n        // Issue: https://github.com/vercel/next.js/issues/53911\n        if (redirectLocation) {\n            state.pushRef.pendingPush = true;\n            mutable.pendingPush = true;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === "string") {\n            // Handle case when navigating to page in `pages` from `app`\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.data as it has been resolved at this point.\n        mutable.inFlightServerAction = null;\n        if (redirectLocation) {\n            const newHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = newHref;\n        }\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("SERVER ACTION APPLY FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, redirectLocation ? (0, _createhreffromurl.createHrefFromUrl)(redirectLocation) : state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (rsc !== null) {\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                    state,\n                    updatedTree: newTree,\n                    updatedCache: cache,\n                    includeNextUrl: Boolean(nextUrl),\n                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                });\n                mutable.cache = cache;\n                mutable.prefetchCache = new Map();\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        resolve(actionResult);\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don\'t update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3VEQW9KZ0JBOzs7ZUFBQUE7OzsyQ0EvSVc7OENBTXBCO3lDQW1CcUI7K0NBQ007NkNBQ0E7eURBQ1U7eURBQ0E7MkNBRWQ7MkRBQ2dCO3VDQUNUOytEQUNhO21EQUNaOzZEQUNVO0FBN0JoRCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEUsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFdBQVcsRUFBRSxHQUNwQyxNQUEwQixHQUV0QkksQ0FBUSxHQUVSQSxtQkFBQUEsQ0FBUTtBQWlDZCxlQUFlQyxrQkFDYkMsS0FBMkIsRUFDM0JDLE9BQXdDLEVBQ3hDQyxLQUE0QztJQUE1QyxNQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBc0IsR0FBNUNGO0lBRUEsTUFBTUcsT0FBTyxNQUFNWCxZQUFZVTtJQUUvQixNQUFNRSxNQUFNLE1BQU1DLE1BQU0sSUFBSTtRQUMxQkMsUUFBUTtRQUNSQyxTQUFTO1lBQ1BDLFFBQVFDLGtCQUFBQSx1QkFBdUI7WUFDL0IsQ0FBQ0Msa0JBQUFBLE1BQU0sQ0FBQyxFQUFFVDtZQUNWLENBQUNVLGtCQUFBQSxzQkFBc0IsQ0FBQyxFQUFFQyxtQkFBbUJDLEtBQUtDLFNBQVMsQ0FBQ2hCLE1BQU1pQixJQUFJO1lBQ3RFLEdBQUl0QixNQUE4QixHQUM5QixDQUVBLEdBQ0EsQ0FBQyxDQUFDO1lBQ04sR0FBSU0sVUFDQTtnQkFDRSxDQUFDa0Isa0JBQUFBLFFBQVEsQ0FBQyxFQUFFbEI7WUFDZCxJQUNBLENBQUMsQ0FBQztRQUNSO1FBQ0FJO0lBQ0Y7SUFFQSxNQUFNZSxXQUFXZCxJQUFJRyxPQUFPLENBQUNZLEdBQUcsQ0FBQztJQUNqQyxJQUFJQztJQUNKLElBQUk7UUFD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TUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQjtnQkFDN0NELE1BQU1ELEdBQUcsR0FBR0E7Z0JBQ1pDLE1BQU1FLFdBQVcsR0FBRztnQkFDcEJDLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBNkIsRUFDM0JILE9BRUFuQyxXQUNBMEIsV0FDQUssbUJBQ0FDO2dCQUdGLE1BQU1PLENBQUFBLEdBQUFBLGlDQUFBQSwrQkFBK0IsRUFBQztvQkFDcEMxRTtvQkFDQTJFLGFBQWFiO29CQUNiYyxjQUFjTjtvQkFDZE8sZ0JBQWdCQyxRQUFRN0U7b0JBQ3hCK0IsY0FBY2EsUUFBUWIsWUFBWSxJQUFJaEMsTUFBTWdDLFlBQVk7Z0JBQzFEO2dCQUVBYSxRQUFReUIsS0FBSyxHQUFHQTtnQkFDaEJ6QixRQUFRa0MsYUFBYSxHQUFHLElBQUlDO1lBQzlCO1lBRUFuQyxRQUFRb0MsV0FBVyxHQUFHbkI7WUFDdEJoQixjQUFjZ0I7UUFDaEI7UUFFQXZCLFFBQVFHO1FBRVIsT0FBT3dDLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ2xGLE9BQU82QztJQUM5QixHQUNBLENBQUNqQjtRQUNDLG1IQUFtSDtRQUNuSGdCLE9BQU9oQjtRQUVQLE9BQU81QjtJQUNUO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXIudHM/Y2YxMiJdLCJuYW1lcyI6WyJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiY3JlYXRlRnJvbUZldGNoIiwiZW5jb2RlUmVwbHkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsImZldGNoU2VydmVyQWN0aW9uIiwic3RhdGUiLCJuZXh0VXJsIiwicGFyYW0iLCJhY3Rpb25JZCIsImFjdGlvbkFyZ3MiLCJib2R5IiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQWNjZXB0IiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJBQ1RJT04iLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJORVhUX1VSTCIsImxvY2F0aW9uIiwiZ2V0IiwicmV2YWxpZGF0ZWRQYXJ0cyIsInJldmFsaWRhdGVkSGVhZGVyIiwicGFyc2UiLCJwYXRocyIsInRhZyIsImNvb2tpZSIsImUiLCJyZWRpcmVjdExvY2F0aW9uIiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJjYW5vbmljYWxVcmwiLCJ3aW5kb3ciLCJocmVmIiwidW5kZWZpbmVkIiwiaXNGbGlnaHRSZXNwb25zZSIsInJlc3BvbnNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsU2VydmVyIiwiYWN0aW9uRmxpZ2h0RGF0YSIsImFjdGlvblJlc3VsdCIsImFjdGlvbiIsInJlamVjdCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwiaW5GbGlnaHRTZXJ2ZXJBY3Rpb24iLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImhhbmRsZUV4dGVybmFsVXJsIiwibmV3SHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiZmxpZ2h0RGF0YVBhdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsInNsaWNlIiwicnNjIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsIkJvb2xlYW4iLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "serverPatchReducer", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse } = action;\n    const [flightData, overrideCanonicalUrl] = serverResponse;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === "string") {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // Slices off the last segment (which is at -4) as it doesn\'t exist in the tree yet\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        const [treePatch] = flightDataPath.slice(-3, -2);\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            "",\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        if (newTree === null) {\n            return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createhreffromurl.createHrefFromUrl)(overrideCanonicalUrl) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0RBZ0JnQkE7OztlQUFBQTs7OytDQWhCa0I7eURBQ1U7eURBQ0E7NkNBT1Y7NkNBQ0Y7MkNBQ0Y7dUNBRU87bURBQ0M7QUFFL0IsU0FBU0EsbUJBQ2RDLEtBQTJCLEVBQzNCQyxNQUF5QjtJQUV6QixNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRDtJQUMzQixNQUFNLENBQUNFLFlBQVlDLHFCQUFxQixHQUFHRjtJQUUzQyxNQUFNRyxVQUFtQixDQUFDO0lBRTFCQSxRQUFRQywwQkFBMEIsR0FBRztJQUVyQyw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPSCxlQUFlLFVBQVU7UUFDbEMsT0FBT0ksQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QlAsT0FDQUssU0FDQUYsWUFDQUgsTUFBTVEsT0FBTyxDQUFDQyxXQUFXO0lBRTdCO0lBRUEsSUFBSUMsY0FBY1YsTUFBTVcsSUFBSTtJQUM1QixJQUFJQyxlQUFlWixNQUFNYSxLQUFLO0lBRTlCLEtBQUssTUFBTUMsa0JBQWtCWCxXQUFZO1FBQ3ZDLG1GQUFtRjtRQUNuRixNQUFNWSxvQkFBb0JELGVBQWVFLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFFbkQsTUFBTSxDQUFDQyxVQUFVLEdBQUdILGVBQWVFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUM5QyxNQUFNRSxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQTJCLEVBRXpDO1lBQUM7ZUFBT0o7U0FBa0IsRUFDMUJMLGFBQ0FPLFdBQ0FqQixNQUFNb0IsWUFBWTtRQUdwQixJQUFJRixZQUFZLE1BQU07WUFDcEIsT0FBT0csQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFxQixFQUFDckIsT0FBT0MsUUFBUWdCO1FBQzlDO1FBRUEsSUFBSUssQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUFDWixhQUFhUSxVQUFVO1lBQ3JELE9BQU9YLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJQLE9BQ0FLLFNBQ0FMLE1BQU1vQixZQUFZLEVBQ2xCcEIsTUFBTVEsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsTUFBTWMsMkJBQTJCbkIsdUJBQzdCb0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDcEIsd0JBQ2xCcUI7UUFFSixJQUFJRiwwQkFBMEI7WUFDNUJsQixRQUFRZSxZQUFZLEdBQUdHO1FBQ3pCO1FBRUEsTUFBTVYsUUFBbUJhLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQjtRQUM3Q0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFBQ2YsY0FBY0MsT0FBT0M7UUFFckNULFFBQVF1QixXQUFXLEdBQUdWO1FBQ3RCYixRQUFRUSxLQUFLLEdBQUdBO1FBRWhCRCxlQUFlQztRQUNmSCxjQUFjUTtJQUNoQjtJQUVBLE9BQU9XLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQzdCLE9BQU9LO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXIudHM/OTExZSJdLCJuYW1lcyI6WyJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGFQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJzbGljZSIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJjYW5vbmljYWxVcmwiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ "(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === "refresh" && // it\'s possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn\'t care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        [\n            rootTree[0],\n            rootTree[1],\n            rootTree[2],\n            "refetch"\n        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{\n            const flightData = fetchResponse[0];\n            if (typeof flightData !== "string") {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that\'s\n                    // just been created & has been written to, but hasn\'t been "committed" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I\'m not 100% sure of this decision, but it seems unlikely that we\'d want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== "refresh") {\n        tree[2] = path;\n        tree[3] = "refresh";\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaUhnQkEsMENBQXdDO2VBQXhDQTs7SUF2Rk1DLGlDQUErQjtlQUEvQkE7Ozs2Q0F2QlU7aURBQ0k7cUNBQ0g7QUFxQjFCLGVBQWVBLGdDQUNwQkMsT0FBd0M7SUFFeEMsTUFBTUMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1DLG9DQUFvQztRQUN4QyxHQUFHSCxPQUFPO1FBQ1ZJLFVBQVVKLFFBQVFLLFdBQVc7UUFDN0JKO0lBQ0Y7QUFDRjtBQUVBLGVBQWVFLG9DQUFvQ0csS0FXbEQ7SUFYa0QsTUFDakRDLEtBQUssRUFDTEYsV0FBVyxFQUNYRyxZQUFZLEVBQ1pDLGNBQWMsRUFDZFIsZUFBZSxFQUNmRyxXQUFXQyxXQUFXLEVBQ3RCSyxZQUFZLEVBSWIsR0FYa0RKO0lBWWpELE1BQU0sR0FBR0ssZ0JBQWdCQyxhQUFhQyxjQUFjLEdBQUdSO0lBQ3ZELE1BQU1TLGdCQUFnQixFQUFFO0lBRXhCLElBQ0VGLGVBQ0FBLGdCQUFnQkYsZ0JBQ2hCRyxrQkFBa0IsYUFDbEIsNEZBQTRGO0lBQzVGLHNEQUFzRDtJQUN0RCxDQUFDWixnQkFBZ0JjLEdBQUcsQ0FBQ0gsY0FDckI7UUFDQVgsZ0JBQWdCZSxHQUFHLENBQUNKLGFBQWEsMkJBQTJCOztRQUU1RCx3SEFBd0g7UUFDeEgsa0lBQWtJO1FBQ2xJLE1BQU1LLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFDdEMsSUFBSUMsSUFBSVAsYUFBYVEsU0FBU0MsTUFBTSxHQUVwQyw4SEFBOEg7UUFDOUg7WUFBQ2pCLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1lBQUU7U0FBVSxFQUNsREssaUJBQWlCRixNQUFNZSxPQUFPLEdBQUcsTUFDakNmLE1BQU1nQixPQUFPLEVBQ2JDLElBQUksQ0FBQyxDQUFDQztZQUNOLE1BQU1DLGFBQWFELGFBQWEsQ0FBQyxFQUFFO1lBQ25DLElBQUksT0FBT0MsZUFBZSxVQUFVO2dCQUNsQyxLQUFLLE1BQU1DLGtCQUFrQkQsV0FBWTtvQkFDdkMsd0ZBQXdGO29CQUN4Riw0R0FBNEc7b0JBQzVHLDRFQUE0RTtvQkFDNUVFLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNwQixjQUFjQSxjQUFjbUI7Z0JBQzlDO1lBQ0YsT0FBTztZQUNMLDRHQUE0RztZQUM1RywrR0FBK0c7WUFDL0csc0VBQXNFO1lBQ3hFO1FBQ0Y7UUFFQWIsY0FBY2UsSUFBSSxDQUFDWjtJQUNyQjtJQUVBLElBQUssTUFBTWEsT0FBT25CLGVBQWdCO1FBQ2hDLE1BQU1vQix1QkFBdUI1QixvQ0FBb0M7WUFDL0RJO1lBQ0FGLGFBQWFNLGNBQWMsQ0FBQ21CLElBQUk7WUFDaEN0QjtZQUNBQztZQUNBUjtZQUNBRztZQUNBTTtRQUNGO1FBRUFJLGNBQWNlLElBQUksQ0FBQ0U7SUFDckI7SUFFQSxNQUFNQyxRQUFRQyxHQUFHLENBQUNuQjtBQUNwQjtBQVFPLFNBQVNoQix5Q0FDZG9DLElBQXVCLEVBQ3ZCQyxJQUFZO0lBRVosTUFBTSxDQUFDQyxTQUFTekIsa0JBQWtCRSxjQUFjLEdBQUdxQjtJQUNuRCxvR0FBb0c7SUFDcEcsSUFBSUUsUUFBUUMsUUFBUSxDQUFDQyxTQUFBQSxnQkFBZ0IsS0FBS3pCLGtCQUFrQixXQUFXO1FBQ3JFcUIsSUFBSSxDQUFDLEVBQUUsR0FBR0M7UUFDVkQsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNaO0lBRUEsSUFBSyxNQUFNSixPQUFPbkIsZUFBZ0I7UUFDaENiLHlDQUF5Q2EsY0FBYyxDQUFDbUIsSUFBSSxFQUFFSztJQUNoRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy50cz83ODg4Il0sIm5hbWVzIjpbImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsInBhcmFtIiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsImZldGNoUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    isThenable: function() {\n        return isThenable;\n    }\n});\nconst ACTION_REFRESH = "refresh";\nconst ACTION_NAVIGATE = "navigate";\nconst ACTION_RESTORE = "restore";\nconst ACTION_SERVER_PATCH = "server-patch";\nconst ACTION_PREFETCH = "prefetch";\nconst ACTION_FAST_REFRESH = "fast-refresh";\nconst ACTION_SERVER_ACTION = "server-action";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind["AUTO"] = "auto";\n    PrefetchKind["FULL"] = "full";\n    PrefetchKind["TEMPORARY"] = "temporary";\n})(PrefetchKind || (PrefetchKind = {}));\nvar PrefetchCacheEntryStatus;\n(function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus["fresh"] = "fresh";\n    PrefetchCacheEntryStatus["reusable"] = "reusable";\n    PrefetchCacheEntryStatus["expired"] = "expired";\n    PrefetchCacheEntryStatus["stale"] = "stale";\n})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));\nfunction isThenable(value) {\n    // TODO: We don\'t gain anything from this abstraction. It\'s unsound, and only\n    // makes sense in the specific places where we use it. So it\'s better to keep\n    // the type coercion inline, instead of leaking this to other places in\n    // the codebase.\n    return value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQVlhQSxxQkFBbUI7ZUFBbkJBOztJQUpBQyxpQkFBZTtlQUFmQTs7SUFHQUMsaUJBQWU7ZUFBZkE7O0lBSkFDLGdCQUFjO2VBQWRBOztJQUVBQyxnQkFBYztlQUFkQTs7SUFJQUMsc0JBQW9CO2VBQXBCQTs7SUFIQUMscUJBQW1CO2VBQW5CQTs7Ozs7Ozs7SUF1UUdDLFlBQVU7ZUFBVkE7OztBQTFRVCxNQUFNSixpQkFBaUI7QUFDdkIsTUFBTUYsa0JBQWtCO0FBQ3hCLE1BQU1HLGlCQUFpQjtBQUN2QixNQUFNRSxzQkFBc0I7QUFDNUIsTUFBTUosa0JBQWtCO0FBQ3hCLE1BQU1GLHNCQUFzQjtBQUM1QixNQUFNSyx1QkFBdUI7O1VBdUl4QkcsWUFBQUE7Ozs7R0FBQUEsZ0JBQUFBLENBQUFBLGVBQUFBLENBQUFBLENBQUFBOztVQThEQUMsd0JBQUFBOzs7OztHQUFBQSw0QkFBQUEsQ0FBQUEsMkJBQUFBLENBQUFBLENBQUFBO0FBK0RMLFNBQVNGLFdBQVdHLEtBQVU7SUFDbkMsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSx1RUFBdUU7SUFDdkUsZ0JBQWdCO0lBQ2hCLE9BQ0VBLFNBQ0MsUUFBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsZUFDL0MsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBRTFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMudHM/ZWYxYyJdLCJuYW1lcyI6WyJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsImlzVGhlbmFibGUiLCJQcmVmZXRjaEtpbmQiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJ2YWx1ZSIsInRoZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "reducer", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\nconst _fastrefreshreducer = __webpack_require__(/*! ./reducers/fast-refresh-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_FAST_REFRESH:\n            {\n                return (0, _fastrefreshreducer.fastRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error("Unknown action");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer = typeof window === "undefined" ? serverReducer : clientReducer;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7MkNBaUVhQTs7O2VBQUFBOzs7Z0RBekROOzZDQU15QjtnREFDRzs0Q0FDSjs0Q0FDQTs2Q0FDQztnREFDRztpREFDQztBQUVwQzs7Q0FFQyxHQUNELFNBQVNDLGNBQ1BDLEtBQTJCLEVBQzNCQyxNQUFzQjtJQUV0QixPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUtDLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNKLE9BQU9DO1lBQ2hDO1FBQ0EsS0FBS0ksb0JBQUFBLG1CQUFtQjtZQUFFO2dCQUN4QixPQUFPQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQUNOLE9BQU9DO1lBQ25DO1FBQ0EsS0FBS00sb0JBQUFBLGNBQWM7WUFBRTtnQkFDbkIsT0FBT0MsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQWMsRUFBQ1IsT0FBT0M7WUFDL0I7UUFDQSxLQUFLUSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBYyxFQUFDVixPQUFPQztZQUMvQjtRQUNBLEtBQUtVLG9CQUFBQSxtQkFBbUI7WUFBRTtnQkFDeEIsT0FBT0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFrQixFQUFDWixPQUFPQztZQUNuQztRQUNBLEtBQUtZLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNkLE9BQU9DO1lBQ2hDO1FBQ0EsS0FBS2Msb0JBQUFBLG9CQUFvQjtZQUFFO2dCQUN6QixPQUFPQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQUNoQixPQUFPQztZQUNwQztRQUNBLCtEQUErRDtRQUMvRDtZQUNFLE1BQU0sSUFBSWdCLE1BQU07SUFDcEI7QUFDRjtBQUVBLFNBQVNDLGNBQ1BsQixLQUEyQixFQUMzQm1CLE9BQXVCO0lBRXZCLE9BQU9uQjtBQUNUO0FBR08sTUFBTUYsVUFDWCxPQUFPc0IsV0FBVyxjQUFjRixnQkFBZ0JuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLnRzPzNjNjUiXSwibmFtZXMiOlsicmVkdWNlciIsImNsaWVudFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJBQ1RJT05fTkFWSUdBVEUiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiQUNUSU9OX1JFU1RPUkUiLCJyZXN0b3JlUmVkdWNlciIsIkFDVElPTl9SRUZSRVNIIiwicmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiZmFzdFJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicHJlZmV0Y2hSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiRXJyb3IiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer.js\n'))},"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":function(module,exports,__webpack_require__){eval(__webpack_require__.ts('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "shouldHardNavigate", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ "(app-pages-browser)/../node_modules/next/dist/client/components/match-segments.js");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn\'t match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0RBUWdCQTs7O2VBQUFBOzs7MkNBSGE7QUFHdEIsU0FBU0EsbUJBQ2RDLGlCQUFpQyxFQUNqQ0MsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUszQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDTSxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUNGLGdCQUFnQkYsVUFBVTtRQUMxQyxrR0FBa0c7UUFDbEcsSUFBSUssTUFBTUMsT0FBTyxDQUFDSixpQkFBaUI7WUFDakMsT0FBTztRQUNUO1FBRUEsc0VBQXNFO1FBQ3RFLE9BQU87SUFDVDtJQUNBLE1BQU1LLGNBQWNULGtCQUFrQlUsTUFBTSxJQUFJO0lBRWhELElBQUlELGFBQWE7UUFDZixPQUFPO0lBQ1Q7SUFFQSxPQUFPVixtQkFDTEMsa0JBQWtCVyxLQUFLLENBQUMsSUFDeEJSLGNBQWMsQ0FBQ0UsaUJBQWlCO0FBRXBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUudHM/MmU5ZiJdLCJuYW1lcyI6WyJzaG91bGRIYXJkTmF2aWdhdGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodFJvdXRlclN0YXRlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiY3VycmVudFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwibWF0Y2hTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwibGFzdFNlZ21lbnQiLCJsZW5ndGgiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n'))}}]);
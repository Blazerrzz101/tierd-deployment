"use strict";exports.id="defaultVendors-_ssr_node_modules_next_dist_client_components_render-from-template-context_js--c8520f",exports.ids=["defaultVendors-_ssr_node_modules_next_dist_client_components_render-from-template-context_js--c8520f"],exports.modules={"(ssr)/../node_modules/next/dist/client/components/render-from-template-context.js":(module,exports,__webpack_require__)=>{eval('/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "default", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "(ssr)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/contexts/app-router-context.js");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozt1REFHZ0NBLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7QUFFakIsTUFBQUMsaUNBQVNDLG1CQUFBQSxDQUFBQSx3S0FBQUE7U0FDdEJBO0lBQ0EsTUFBQUMsV0FBQSxJQUFPQyxPQUFBQyxVQUFBLEVBQUFKLCtCQUFBSyxlQUFBO1dBQUdILFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLFlBQUFBLEdBQUFBLEVBQUFBLFlBQUFBLFFBQUFBLEVBQUFBOztJQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LnRzeD85YWMyIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsImNoaWxkcmVuIiwiX3JlYWN0IiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/render-from-template-context.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "applyFlightData", ({\n    enumerable: true,\n    get: function() {\n        return applyFlightData;\n    }\n}));\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _fillcachewithnewsubtreedata = __webpack_require__(/*! ./fill-cache-with-new-subtree-data */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js");\nfunction applyFlightData(existingCache, cache, flightDataPath, prefetchEntry) {\n    // The one before last item is the router state tree patch\n    const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3);\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (cacheNodeSeedData === null) {\n        return false;\n    }\n    if (flightDataPath.length === 3) {\n        const rsc = cacheNodeSeedData[2];\n        const loading = cacheNodeSeedData[3];\n        cache.loading = loading;\n        cache.rsc = rsc;\n        // This is a PPR-only field. When PPR is enabled, we shouldn\'t hit\n        // this path during a navigation, but until PPR is fully implemented\n        // yet it\'s possible the existing node does have a non-null\n        // `prefetchRsc`. As an incremental step, we\'ll just de-opt to the\n        // old behavior â€” no PPR value.\n        cache.prefetchRsc = null;\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, existingCache, treePatch, cacheNodeSeedData, head, prefetchEntry);\n    } else {\n        // Copy rsc for the root node of the cache.\n        cache.rsc = existingCache.rsc;\n        // This is a PPR-only field. Unlike the previous branch, since we\'re\n        // just cloning the existing cache node, we might as well keep the\n        // PPR value, if it exists.\n        cache.prefetchRsc = existingCache.prefetchRsc;\n        cache.parallelRoutes = new Map(existingCache.parallelRoutes);\n        cache.loading = existingCache.loading;\n        // Create a copy of the existing cache with the rsc applied.\n        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(cache, existingCache, flightDataPath, prefetchEntry);\n    }\n    return true;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-flight-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1mbGlnaHQtZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQU1nQkE7OztlQUFBQTs7OzJEQUo4Qjt5REFDRjtBQUdyQyxTQUFTQSxnQkFDZEMsYUFBd0IsRUFDeEJDLEtBQWdCLEVBQ2hCQyxjQUE4QixFQUM5QkMsYUFBa0M7SUFFbEMsMERBQTBEO0lBQzFELE1BQU0sQ0FBQ0MsV0FBV0MsbUJBQW1CQyxLQUFLLEdBQUdKLGVBQWVLLEtBQUssQ0FBQyxDQUFDO0lBRW5FLDhGQUE4RjtJQUM5RixJQUFJRixzQkFBc0IsTUFBTTtRQUM5QixPQUFPO0lBQ1Q7SUFFQSxJQUFJSCxlQUFlTSxNQUFNLEtBQUssR0FBRztRQUMvQixNQUFNQyxNQUFNSixpQkFBaUIsQ0FBQyxFQUFFO1FBQ2hDLE1BQU1LLFVBQVVMLGlCQUFpQixDQUFDLEVBQUU7UUFDcENKLE1BQU1TLE9BQU8sR0FBR0E7UUFDaEJULE1BQU1RLEdBQUcsR0FBR0E7UUFDWixrRUFBa0U7UUFDbEUsb0VBQW9FO1FBQ3BFLDJEQUEyRDtRQUMzRCxrRUFBa0U7UUFDbEUsK0JBQStCO1FBQy9CUixNQUFNVSxXQUFXLEdBQUc7UUFDcEJDLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBNkIsRUFDM0JYLE9BQ0FELGVBQ0FJLFdBQ0FDLG1CQUNBQyxNQUNBSDtJQUVKLE9BQU87UUFDTCwyQ0FBMkM7UUFDM0NGLE1BQU1RLEdBQUcsR0FBR1QsY0FBY1MsR0FBRztRQUM3QixvRUFBb0U7UUFDcEUsa0VBQWtFO1FBQ2xFLDJCQUEyQjtRQUMzQlIsTUFBTVUsV0FBVyxHQUFHWCxjQUFjVyxXQUFXO1FBQzdDVixNQUFNWSxjQUFjLEdBQUcsSUFBSUMsSUFBSWQsY0FBY2EsY0FBYztRQUMzRFosTUFBTVMsT0FBTyxHQUFHVixjQUFjVSxPQUFPO1FBQ3JDLDREQUE0RDtRQUM1REssQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUN6QmQsT0FDQUQsZUFDQUUsZ0JBQ0FDO0lBRUo7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FwcGx5LWZsaWdodC1kYXRhLnRzPzI4YmMiXSwibmFtZXMiOlsiYXBwbHlGbGlnaHREYXRhIiwiZXhpc3RpbmdDYWNoZSIsImNhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJwcmVmZXRjaEVudHJ5IiwidHJlZVBhdGNoIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwic2xpY2UiLCJsZW5ndGgiLCJyc2MiLCJsb2FkaW5nIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "applyRouterStatePatchToTree", ({\n    enumerable: true,\n    get: function() {\n        return applyRouterStatePatchToTree;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ "(ssr)/../node_modules/next/dist/shared/lib/segment.js");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ "(ssr)/../node_modules/next/dist/client/components/match-segments.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn\'t have them.\n */ function applyPatch(initialTree, patchTree, flightSegmentPath) {\n    const [initialSegment, initialParallelRoutes] = initialTree;\n    const [patchSegment, patchParallelRoutes] = patchTree;\n    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n    // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {\n        return initialTree;\n    }\n    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {\n        const newParallelRoutes = {};\n        for(const key in initialParallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);\n            } else {\n                newParallelRoutes[key] = initialParallelRoutes[key];\n            }\n        }\n        for(const key in patchParallelRoutes){\n            if (newParallelRoutes[key]) {\n                continue;\n            }\n            newParallelRoutes[key] = patchParallelRoutes[key];\n        }\n        const tree = [\n            initialSegment,\n            newParallelRoutes\n        ];\n        // Copy over the existing tree\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {\n    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);\n        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        {\n            ...parallelRoutes,\n            [parallelRouteKey]: parallelRoutePatch\n        },\n        url,\n        refetch\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);\n    return tree;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytEQThFZ0JBOzs7ZUFBQUE7OztxQ0ExRW9COzJDQUNQOzZEQUM0QjtBQUV6RDs7Q0FFQyxHQUNELFNBQVNDLFdBQ1BDLFdBQThCLEVBQzlCQyxTQUE0QixFQUM1QkMsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsZ0JBQWdCQyxzQkFBc0IsR0FBR0o7SUFDaEQsTUFBTSxDQUFDSyxjQUFjQyxvQkFBb0IsR0FBR0w7SUFFNUMsa0dBQWtHO0lBQ2xHLGlGQUFpRjtJQUNqRixJQUNFSSxpQkFBaUJFLFNBQUFBLG1CQUFtQixJQUNwQ0osbUJBQW1CSSxTQUFBQSxtQkFBbUIsRUFDdEM7UUFDQSxPQUFPUDtJQUNUO0lBRUEsSUFBSVEsQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDTCxnQkFBZ0JFLGVBQWU7UUFDOUMsTUFBTUksb0JBQTBDLENBQUM7UUFDakQsSUFBSyxNQUFNQyxPQUFPTixzQkFBdUI7WUFDdkMsTUFBTU8sOEJBQ0osT0FBT0wsbUJBQW1CLENBQUNJLElBQUksS0FBSztZQUN0QyxJQUFJQyw2QkFBNkI7Z0JBQy9CRixpQkFBaUIsQ0FBQ0MsSUFBSSxHQUFHWCxXQUN2QksscUJBQXFCLENBQUNNLElBQUksRUFDMUJKLG1CQUFtQixDQUFDSSxJQUFJLEVBQ3hCUjtZQUVKLE9BQU87Z0JBQ0xPLGlCQUFpQixDQUFDQyxJQUFJLEdBQUdOLHFCQUFxQixDQUFDTSxJQUFJO1lBQ3JEO1FBQ0Y7UUFFQSxJQUFLLE1BQU1BLE9BQU9KLG9CQUFxQjtZQUNyQyxJQUFJRyxpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFO2dCQUMxQjtZQUNGO1lBRUFELGlCQUFpQixDQUFDQyxJQUFJLEdBQUdKLG1CQUFtQixDQUFDSSxJQUFJO1FBQ25EO1FBRUEsTUFBTUUsT0FBMEI7WUFBQ1Q7WUFBZ0JNO1NBQWtCO1FBRW5FLDhCQUE4QjtRQUM5QixJQUFJVCxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ2xCWSxJQUFJLENBQUMsRUFBRSxHQUFHWixXQUFXLENBQUMsRUFBRTtRQUMxQjtRQUVBLElBQUlBLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDbEJZLElBQUksQ0FBQyxFQUFFLEdBQUdaLFdBQVcsQ0FBQyxFQUFFO1FBQzFCO1FBRUEsSUFBSUEsV0FBVyxDQUFDLEVBQUUsRUFBRTtZQUNsQlksSUFBSSxDQUFDLEVBQUUsR0FBR1osV0FBVyxDQUFDLEVBQUU7UUFDMUI7UUFFQSxPQUFPWTtJQUNUO0lBRUEsT0FBT1g7QUFDVDtBQU9PLFNBQVNILDRCQUNkSSxpQkFBb0MsRUFDcENXLGlCQUFvQyxFQUNwQ0MsU0FBNEIsRUFDNUJDLElBQVk7SUFFWixNQUFNLENBQUNDLFNBQVNDLGdCQUFnQkMsS0FBS0MsU0FBU0MsYUFBYSxHQUN6RFA7SUFFRixlQUFlO0lBQ2YsSUFBSVgsa0JBQWtCbUIsTUFBTSxLQUFLLEdBQUc7UUFDbEMsTUFBTVQsT0FBMEJiLFdBQzlCYyxtQkFDQUMsV0FDQVo7UUFHRm9CLENBQUFBLEdBQUFBLGlDQUFBQSx3Q0FBd0MsRUFBQ1YsTUFBTUc7UUFFL0MsT0FBT0g7SUFDVDtJQUVBLE1BQU0sQ0FBQ1csZ0JBQWdCQyxpQkFBaUIsR0FBR3RCO0lBRTNDLGlHQUFpRztJQUNqRyxJQUFJLENBQUNNLENBQUFBLEdBQUFBLGVBQUFBLFlBQVksRUFBQ2UsZ0JBQWdCUCxVQUFVO1FBQzFDLE9BQU87SUFDVDtJQUVBLE1BQU1TLGNBQWN2QixrQkFBa0JtQixNQUFNLEtBQUs7SUFFakQsSUFBSUs7SUFDSixJQUFJRCxhQUFhO1FBQ2ZDLHFCQUFxQjNCLFdBQ25Ca0IsY0FBYyxDQUFDTyxpQkFBaUIsRUFDaENWLFdBQ0FaO0lBRUosT0FBTztRQUNMd0IscUJBQXFCNUIsNEJBQ25CSSxrQkFBa0J5QixLQUFLLENBQUMsSUFDeEJWLGNBQWMsQ0FBQ08saUJBQWlCLEVBQ2hDVixXQUNBQztRQUdGLElBQUlXLHVCQUF1QixNQUFNO1lBQy9CLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTWQsT0FBMEI7UUFDOUJWLGlCQUFpQixDQUFDLEVBQUU7UUFDcEI7WUFDRSxHQUFHZSxjQUFjO1lBQ2pCLENBQUNPLGlCQUFpQixFQUFFRTtRQUN0QjtRQUNBUjtRQUNBQztLQUNEO0lBRUQscUNBQXFDO0lBQ3JDLElBQUlDLGNBQWM7UUFDaEJSLElBQUksQ0FBQyxFQUFFLEdBQUc7SUFDWjtJQUVBVSxDQUFBQSxHQUFBQSxpQ0FBQUEsd0NBQXdDLEVBQUNWLE1BQU1HO0lBRS9DLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLnRzPzRkMTIiXSwibmFtZXMiOlsiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiYXBwbHlQYXRjaCIsImluaXRpYWxUcmVlIiwicGF0Y2hUcmVlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpbml0aWFsU2VnbWVudCIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsInBhdGNoU2VnbWVudCIsInBhdGNoUGFyYWxsZWxSb3V0ZXMiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwibWF0Y2hTZWdtZW50IiwibmV3UGFyYWxsZWxSb3V0ZXMiLCJrZXkiLCJpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMiLCJ0cmVlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJ0cmVlUGF0Y2giLCJwYXRoIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwidXJsIiwicmVmZXRjaCIsImlzUm9vdExheW91dCIsImxlbmd0aCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJsYXN0U2VnbWVudCIsInBhcmFsbGVsUm91dGVQYXRjaCIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "clearCacheNodeDataForSegmentPath", ({\n    enumerable: true,\n    get: function() {\n        return clearCacheNodeDataForSegmentPath;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap == null ? void 0 : existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    // In case of last segment start off the fetch at this level and don\'t copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn\'t have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(cacheKey, {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: childCacheNode.lazyDataResolved,\n            loading: childCacheNode.loading\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    return clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jbGVhci1jYWNoZS1ub2RlLWRhdGEtZm9yLXNlZ21lbnQtcGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7O29FQU9nQkE7OztlQUFBQTs7O2tEQUxxQjtBQUs5QixTQUFTQSxpQ0FDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxpQkFBb0M7SUFFcEMsTUFBTUMsY0FBY0Qsa0JBQWtCRSxNQUFNLElBQUk7SUFFaEQsTUFBTSxDQUFDQyxrQkFBa0JDLFFBQVEsR0FBR0o7SUFDcEMsTUFBTUssV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtJQUV0QyxNQUFNRywwQkFDSlIsY0FBY1MsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRW5DLElBQUlPLGtCQUFrQlosU0FBU1UsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRWxELElBQUksQ0FBQ08sbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNuRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVCxTQUFTVSxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Qsa0JBQWtCTztJQUNoRDtJQUVBLE1BQU1HLHlCQUF5Qk4sMkJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHdCQUF5QkUsR0FBRyxDQUFDSjtJQUM1RCxJQUFJUyxpQkFBaUJKLGdCQUFnQkQsR0FBRyxDQUFDSjtJQUV6Qyx5RkFBeUY7SUFDekYsSUFBSUosYUFBYTtRQUNmLElBQ0UsQ0FBQ2Esa0JBQ0QsQ0FBQ0EsZUFBZUMsUUFBUSxJQUN4QkQsbUJBQW1CRCx3QkFDbkI7WUFDQUgsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVU7Z0JBQzVCVSxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxhQUFhO2dCQUNiQyxNQUFNO2dCQUNOQyxjQUFjO2dCQUNkWCxnQkFBZ0IsSUFBSUc7Z0JBQ3BCUyxrQkFBa0I7Z0JBQ2xCQyxTQUFTO1lBQ1g7UUFDRjtRQUNBO0lBQ0Y7SUFFQSxJQUFJLENBQUNQLGtCQUFrQixDQUFDRCx3QkFBd0I7UUFDOUMsK0VBQStFO1FBQy9FLElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ25CSixnQkFBZ0JFLEdBQUcsQ0FBQ1AsVUFBVTtnQkFDNUJVLFVBQVU7Z0JBQ1ZDLEtBQUs7Z0JBQ0xDLGFBQWE7Z0JBQ2JDLE1BQU07Z0JBQ05DLGNBQWM7Z0JBQ2RYLGdCQUFnQixJQUFJRztnQkFDcEJTLGtCQUFrQjtnQkFDbEJDLFNBQVM7WUFDWDtRQUNGO1FBQ0E7SUFDRjtJQUVBLElBQUlQLG1CQUFtQkQsd0JBQXdCO1FBQzdDQyxpQkFBaUI7WUFDZkMsVUFBVUQsZUFBZUMsUUFBUTtZQUNqQ0MsS0FBS0YsZUFBZUUsR0FBRztZQUN2QkMsYUFBYUgsZUFBZUcsV0FBVztZQUN2Q0MsTUFBTUosZUFBZUksSUFBSTtZQUN6QkMsY0FBY0wsZUFBZUssWUFBWTtZQUN6Q1gsZ0JBQWdCLElBQUlHLElBQUlHLGVBQWVOLGNBQWM7WUFDckRZLGtCQUFrQk4sZUFBZU0sZ0JBQWdCO1lBQ2pEQyxTQUFTUCxlQUFlTyxPQUFPO1FBQ2pDO1FBQ0FYLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVUztJQUNoQztJQUVBLE9BQU9qQixpQ0FDTGlCLGdCQUNBRCx3QkFDQWIsa0JBQWtCc0IsS0FBSyxDQUFDO0FBRTVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jbGVhci1jYWNoZS1ub2RlLWRhdGEtZm9yLXNlZ21lbnQtcGF0aC50cz9hYThkIl0sIm5hbWVzIjpbImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImxhenlEYXRhUmVzb2x2ZWQiLCJsb2FkaW5nIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    computeChangedPath: function() {\n        return computeChangedPath;\n    },\n    extractPathFromFlightRouterState: function() {\n        return extractPathFromFlightRouterState;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../server/future/helpers/interception-routes */ "(ssr)/../node_modules/next/dist/server/future/helpers/interception-routes.js");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ "(ssr)/../node_modules/next/dist/shared/lib/segment.js");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ "(ssr)/../node_modules/next/dist/client/components/match-segments.js");\nconst removeLeadingSlash = (segment)=>{\n    return segment[0] === "/" ? segment.slice(1) : segment;\n};\nconst segmentToPathname = (segment)=>{\n    if (typeof segment === "string") {\n        // \'children\' is not a valid path -- it\'s technically a parallel route that corresponds with the current segment\'s page\n        // if we don\'t skip it, then the computed pathname might be something like `/children` which doesn\'t make sense.\n        if (segment === "children") return "";\n        return segment;\n    }\n    return segment[1];\n};\nfunction normalizeSegments(segments) {\n    return segments.reduce((acc, segment)=>{\n        segment = removeLeadingSlash(segment);\n        if (segment === "" || (0, _segment.isGroupSegment)(segment)) {\n            return acc;\n        }\n        return acc + "/" + segment;\n    }, "") || "/";\n}\nfunction extractPathFromFlightRouterState(flightRouterState) {\n    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];\n    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;\n    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return "";\n    const segments = [\n        segmentToPathname(segment)\n    ];\n    var _flightRouterState_;\n    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};\n    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;\n    if (childrenPath !== undefined) {\n        segments.push(childrenPath);\n    } else {\n        for (const [key, value] of Object.entries(parallelRoutes)){\n            if (key === "children") continue;\n            const childPath = extractPathFromFlightRouterState(value);\n            if (childPath !== undefined) {\n                segments.push(childPath);\n            }\n        }\n    }\n    return normalizeSegments(segments);\n}\nfunction computeChangedPathImpl(treeA, treeB) {\n    const [segmentA, parallelRoutesA] = treeA;\n    const [segmentB, parallelRoutesB] = treeB;\n    const normalizedSegmentA = segmentToPathname(segmentA);\n    const normalizedSegmentB = segmentToPathname(segmentB);\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {\n        return "";\n    }\n    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {\n        var _extractPathFromFlightRouterState;\n        // once we find where the tree changed, we compute the rest of the path by traversing the tree\n        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : "";\n    }\n    for(const parallelRouterKey in parallelRoutesA){\n        if (parallelRoutesB[parallelRouterKey]) {\n            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);\n            if (changedPath !== null) {\n                return segmentToPathname(segmentB) + "/" + changedPath;\n            }\n        }\n    }\n    return null;\n}\nfunction computeChangedPath(treeA, treeB) {\n    const changedPath = computeChangedPathImpl(treeA, treeB);\n    if (changedPath == null || changedPath === "/") {\n        return changedPath;\n    }\n    // lightweight normalization to remove route groups\n    return normalizeSegments(changedPath.split("/"));\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=compute-changed-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF1SGdCQSxvQkFBa0I7ZUFBbEJBOztJQTlFQUMsa0NBQWdDO2VBQWhDQTs7O2dEQXJDMkI7cUNBS3BDOzJDQUNzQjtBQUU3QixNQUFNQyxxQkFBcUIsQ0FBQ0M7SUFDMUIsT0FBT0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxRQUFRQyxLQUFLLENBQUMsS0FBS0Q7QUFDakQ7QUFFQSxNQUFNRSxvQkFBb0IsQ0FBQ0Y7SUFDekIsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDL0IsdUhBQXVIO1FBQ3ZILGdIQUFnSDtRQUNoSCxJQUFJQSxZQUFZLFlBQVksT0FBTztRQUVuQyxPQUFPQTtJQUNUO0lBRUEsT0FBT0EsT0FBTyxDQUFDLEVBQUU7QUFDbkI7QUFFQSxTQUFTRyxrQkFBa0JDLFFBQWtCO0lBQzNDLE9BQ0VBLFNBQVNDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLTjtRQUNwQkEsVUFBVUQsbUJBQW1CQztRQUM3QixJQUFJQSxZQUFZLE1BQU1PLENBQUFBLEdBQUFBLFNBQUFBLGNBQWMsRUFBQ1AsVUFBVTtZQUM3QyxPQUFPTTtRQUNUO1FBRUEsT0FBT0EsTUFBTyxNQUFHTjtJQUNuQixHQUFHLE9BQU87QUFFZDtBQUVPLFNBQVNGLGlDQUNkVSxpQkFBb0M7SUFFcEMsTUFBTVIsVUFBVVMsTUFBTUMsT0FBTyxDQUFDRixpQkFBaUIsQ0FBQyxFQUFFLElBQzlDQSxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUN2QkEsaUJBQWlCLENBQUMsRUFBRTtJQUV4QixJQUNFUixZQUFZVyxTQUFBQSxtQkFBbUIsSUFDL0JDLG9CQUFBQSwwQkFBMEIsQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLElBQU1kLFFBQVFlLFVBQVUsQ0FBQ0QsS0FFMUQsT0FBT0U7SUFFVCxJQUFJaEIsUUFBUWUsVUFBVSxDQUFDRSxTQUFBQSxnQkFBZ0IsR0FBRyxPQUFPO0lBRWpELE1BQU1iLFdBQVc7UUFBQ0Ysa0JBQWtCRjtLQUFTO1FBQ3RCUTtJQUF2QixNQUFNVSxpQkFBaUJWLENBQUFBLHNCQUFBQSxpQkFBaUIsQ0FBQyxFQUFFLFlBQXBCQSxzQkFBd0IsQ0FBQztJQUVoRCxNQUFNVyxlQUFlRCxlQUFlRSxRQUFRLEdBQ3hDdEIsaUNBQWlDb0IsZUFBZUUsUUFBUSxJQUN4REo7SUFFSixJQUFJRyxpQkFBaUJILFdBQVc7UUFDOUJaLFNBQVNpQixJQUFJLENBQUNGO0lBQ2hCLE9BQU87UUFDTCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNQLGdCQUFpQjtZQUN6RCxJQUFJSSxRQUFRLFlBQVk7WUFFeEIsTUFBTUksWUFBWTVCLGlDQUFpQ3lCO1lBRW5ELElBQUlHLGNBQWNWLFdBQVc7Z0JBQzNCWixTQUFTaUIsSUFBSSxDQUFDSztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPdkIsa0JBQWtCQztBQUMzQjtBQUVBLFNBQVN1Qix1QkFDUEMsS0FBd0IsRUFDeEJDLEtBQXdCO0lBRXhCLE1BQU0sQ0FBQ0MsVUFBVUMsZ0JBQWdCLEdBQUdIO0lBQ3BDLE1BQU0sQ0FBQ0ksVUFBVUMsZ0JBQWdCLEdBQUdKO0lBRXBDLE1BQU1LLHFCQUFxQmhDLGtCQUFrQjRCO0lBQzdDLE1BQU1LLHFCQUFxQmpDLGtCQUFrQjhCO0lBRTdDLElBQ0VwQixvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FDN0IsQ0FBQ0MsSUFDQ29CLG1CQUFtQm5CLFVBQVUsQ0FBQ0QsTUFBTXFCLG1CQUFtQnBCLFVBQVUsQ0FBQ0QsS0FFdEU7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNzQixDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUNOLFVBQVVFLFdBQVc7WUFFOUJsQztRQURQLDhGQUE4RjtRQUM5RixPQUFPQSxDQUFBQSxvQ0FBQUEsaUNBQWlDK0IsTUFBQUEsS0FBQUEsT0FBakMvQixvQ0FBMkM7SUFDcEQ7SUFFQSxJQUFLLE1BQU11QyxxQkFBcUJOLGdCQUFpQjtRQUMvQyxJQUFJRSxlQUFlLENBQUNJLGtCQUFrQixFQUFFO1lBQ3RDLE1BQU1DLGNBQWNYLHVCQUNsQkksZUFBZSxDQUFDTSxrQkFBa0IsRUFDbENKLGVBQWUsQ0FBQ0ksa0JBQWtCO1lBRXBDLElBQUlDLGdCQUFnQixNQUFNO2dCQUN4QixPQUFPcEMsa0JBQXFCOEIsWUFBVSxNQUFHTTtZQUMzQztRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTekMsbUJBQ2QrQixLQUF3QixFQUN4QkMsS0FBd0I7SUFFeEIsTUFBTVMsY0FBY1gsdUJBQXVCQyxPQUFPQztJQUVsRCxJQUFJUyxlQUFlLFFBQVFBLGdCQUFnQixLQUFLO1FBQzlDLE9BQU9BO0lBQ1Q7SUFFQSxtREFBbUQ7SUFDbkQsT0FBT25DLGtCQUFrQm1DLFlBQVlDLEtBQUssQ0FBQztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY29tcHV0ZS1jaGFuZ2VkLXBhdGgudHM/YzFjMyJdLCJuYW1lcyI6WyJjb21wdXRlQ2hhbmdlZFBhdGgiLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsInJlbW92ZUxlYWRpbmdTbGFzaCIsInNlZ21lbnQiLCJzbGljZSIsInNlZ21lbnRUb1BhdGhuYW1lIiwibm9ybWFsaXplU2VnbWVudHMiLCJzZWdtZW50cyIsInJlZHVjZSIsImFjYyIsImlzR3JvdXBTZWdtZW50IiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJBcnJheSIsImlzQXJyYXkiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwiSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMiLCJzb21lIiwibSIsInN0YXJ0c1dpdGgiLCJ1bmRlZmluZWQiLCJQQUdFX1NFR01FTlRfS0VZIiwicGFyYWxsZWxSb3V0ZXMiLCJjaGlsZHJlblBhdGgiLCJjaGlsZHJlbiIsInB1c2giLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJjaGlsZFBhdGgiLCJjb21wdXRlQ2hhbmdlZFBhdGhJbXBsIiwidHJlZUEiLCJ0cmVlQiIsInNlZ21lbnRBIiwicGFyYWxsZWxSb3V0ZXNBIiwic2VnbWVudEIiLCJwYXJhbGxlbFJvdXRlc0IiLCJub3JtYWxpemVkU2VnbWVudEEiLCJub3JtYWxpemVkU2VnbWVudEIiLCJtYXRjaFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcktleSIsImNoYW5nZWRQYXRoIiwic3BsaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "createHrefFromUrl", ({\n    enumerable: true,\n    get: function() {\n        return createHrefFromUrl;\n    }\n}));\nfunction createHrefFromUrl(url, includeHash) {\n    if (includeHash === void 0) includeHash = true;\n    return url.pathname + url.search + (includeHash ? url.hash : "");\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybC5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0Esa0JBQ2RDLEdBQThDLEVBQzlDQyxXQUEyQjtJQUEzQkEsSUFBQUEsZ0JBQUFBLEtBQUFBLEdBQUFBLGNBQXVCO0lBRXZCLE9BQU9ELElBQUlFLFFBQVEsR0FBR0YsSUFBSUcsTUFBTSxHQUFJRixDQUFBQSxjQUFjRCxJQUFJSSxJQUFJLEdBQUc7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsLnRzP2UwZWIiXSwibmFtZXMiOlsiY3JlYXRlSHJlZkZyb21VcmwiLCJ1cmwiLCJpbmNsdWRlSGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "createInitialRouterState", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\nfunction createInitialRouterState(param) {\n    let { buildId, initialTree, initialSeedData, urlParts, initialParallelRoutes, location, initialHead, couldBeIntercepted } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don\'t interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = urlParts.join("/");\n    const isServer = !location;\n    const rsc = initialSeedData[2];\n    const cache = {\n        lazyData: null,\n        rsc: rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n        lazyDataResolved: false,\n        loading: initialSeedData[3]\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can\'t be rendered, it\'s only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn\'t been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialSeedData, initialHead);\n    }\n    var _ref;\n    const initialState = {\n        buildId,\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (location) {\n        // Seed the prefetch cache with this page\'s data.\n        // This is to prevent needlessly re-prefetching a page that is already reusable,\n        // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n        const url = new URL("" + location.pathname + location.search, location.origin);\n        const initialFlightData = [\n            [\n                "",\n                initialTree,\n                null,\n                null\n            ]\n        ];\n        (0, _prefetchcacheutils.createPrefetchCacheEntryForInitialLoad)({\n            url,\n            kind: _routerreducertypes.PrefetchKind.AUTO,\n            data: [\n                initialFlightData,\n                undefined,\n                false,\n                couldBeIntercepted\n            ],\n            tree: initialState.tree,\n            prefetchCache: initialState.prefetchCache,\n            nextUrl: initialState.nextUrl\n        });\n    }\n    return initialState;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs0REEwQmdCQTs7O2VBQUFBOzs7K0NBbEJrQjsyREFDWTtnREFDRztnREFDTTtnREFDRDs2REFDRztBQWFsRCxTQUFTQSx5QkFBeUJDLEtBU1Y7SUFUVSxNQUN2Q0MsT0FBTyxFQUNQQyxXQUFXLEVBQ1hDLGVBQWUsRUFDZkMsUUFBUSxFQUNSQyxxQkFBcUIsRUFDckJDLFFBQVEsRUFDUkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDVyxHQVRVUjtJQVV2QyxzRkFBc0Y7SUFDdEYsa0dBQWtHO0lBQ2xHLG1DQUFtQztJQUNuQyxNQUFNUyxzQkFBc0JMLFNBQVNNLElBQUksQ0FBQztJQUMxQyxNQUFNQyxXQUFXLENBQUNMO0lBQ2xCLE1BQU1NLE1BQU1ULGVBQWUsQ0FBQyxFQUFFO0lBRTlCLE1BQU1VLFFBQW1CO1FBQ3ZCQyxVQUFVO1FBQ1ZGLEtBQUtBO1FBQ0xHLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2Qsb0pBQW9KO1FBQ3BKQyxnQkFBZ0JQLFdBQVcsSUFBSVEsUUFBUWQ7UUFDdkNlLGtCQUFrQjtRQUNsQkMsU0FBU2xCLGVBQWUsQ0FBQyxFQUFFO0lBQzdCO0lBRUEsTUFBTW1CLGVBRUosa0pBQWtKO0lBQ2xKaEIsV0FFSWlCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ2pCLFlBQ2xCRztJQUVOZSxDQUFBQSxHQUFBQSxpQ0FBQUEsd0NBQXdDLEVBQUN0QixhQUFhb0I7SUFFdEQsTUFBTUcsZ0JBQWdCLElBQUlOO0lBRTFCLHlFQUF5RTtJQUN6RSxJQUFJZCwwQkFBMEIsUUFBUUEsc0JBQXNCcUIsSUFBSSxLQUFLLEdBQUc7UUFDdEVDLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBNkIsRUFDM0JkLE9BQ0FlLFdBQ0ExQixhQUNBQyxpQkFDQUk7SUFFSjtRQXVCS3NCO0lBckJMLE1BQU1DLGVBQWU7UUFDbkI3QjtRQUNBOEIsTUFBTTdCO1FBQ05XO1FBQ0FZO1FBQ0FPLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsbUVBQW1FO1lBQ25FLGdGQUFnRjtZQUNoRkMsNEJBQTRCO1FBQzlCO1FBQ0FDLG1CQUFtQjtZQUNqQkMsT0FBTztZQUNQQyxnQkFBZ0I7WUFDaEJDLGNBQWM7WUFDZEMsY0FBYyxFQUFFO1FBQ2xCO1FBQ0FsQjtRQUNBbUIsU0FFRSxDQUFDWixPQUFBQSxDQUFBQSxHQUFBQSxvQkFBQUEsZ0NBQWdDLEVBQUMzQixnQkFBZ0JJLENBQUFBLFlBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFNBQVVvQyxRQUFRLGFBQW5FYixPQUNEO0lBQ0o7SUFFQSxJQUFJdkIsVUFBVTtRQUNaLGlEQUFpRDtRQUNqRCxnRkFBZ0Y7UUFDaEYsK0ZBQStGO1FBQy9GLE1BQU1xQyxNQUFNLElBQUlDLElBQ2QsS0FBR3RDLFNBQVNvQyxRQUFRLEdBQUdwQyxTQUFTdUMsTUFBTSxFQUN0Q3ZDLFNBQVN3QyxNQUFNO1FBR2pCLE1BQU1DLG9CQUFnQztZQUFDO2dCQUFDO2dCQUFJN0M7Z0JBQWE7Z0JBQU07YUFBSztTQUFDO1FBQ3JFOEMsQ0FBQUEsR0FBQUEsb0JBQUFBLHNDQUFzQyxFQUFDO1lBQ3JDTDtZQUNBTSxNQUFNQyxvQkFBQUEsWUFBWSxDQUFDQyxJQUFJO1lBQ3ZCQyxNQUFNO2dCQUFDTDtnQkFBbUJuQjtnQkFBVztnQkFBT3BCO2FBQW1CO1lBQy9EdUIsTUFBTUQsYUFBYUMsSUFBSTtZQUN2Qk4sZUFBZUssYUFBYUwsYUFBYTtZQUN6Q2dCLFNBQVNYLGFBQWFXLE9BQU87UUFDL0I7SUFDRjtJQUVBLE9BQU9YO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS50cz9kNTAwIl0sIm5hbWVzIjpbImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsInBhcmFtIiwiYnVpbGRJZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbFNlZWREYXRhIiwidXJsUGFydHMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJsb2NhdGlvbiIsImluaXRpYWxIZWFkIiwiY291bGRCZUludGVyY2VwdGVkIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImpvaW4iLCJpc1NlcnZlciIsInJzYyIsImNhY2hlIiwibGF6eURhdGEiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxhenlEYXRhUmVzb2x2ZWQiLCJsb2FkaW5nIiwiY2Fub25pY2FsVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicHJlZmV0Y2hDYWNoZSIsInNpemUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInVuZGVmaW5lZCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiaW5pdGlhbFN0YXRlIiwidHJlZSIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiYXBwbHkiLCJvbmx5SGFzaENoYW5nZSIsImhhc2hGcmFnbWVudCIsInNlZ21lbnRQYXRocyIsIm5leHRVcmwiLCJwYXRobmFtZSIsInVybCIsIlVSTCIsInNlYXJjaCIsIm9yaWdpbiIsImluaXRpYWxGbGlnaHREYXRhIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5Rm9ySW5pdGlhbExvYWQiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "createRouterCacheKey", ({\n    enumerable: true,\n    get: function() {\n        return createRouterCacheKey;\n    }\n}));\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ "(ssr)/../node_modules/next/dist/shared/lib/segment.js");\nfunction createRouterCacheKey(segment, withoutSearchParameters) {\n    if (withoutSearchParameters === void 0) withoutSearchParameters = false;\n    // if the segment is an array, it means it\'s a dynamic segment\n    // for example, [\'lang\', \'en\', \'d\']. We need to convert it to a string to store it as a cache node key.\n    if (Array.isArray(segment)) {\n        return segment[0] + "|" + segment[1] + "|" + segment[2];\n    }\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\n    // When `withoutSearchParameters` is true, we only want to return the page segment\n    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return _segment.PAGE_SEGMENT_KEY;\n    }\n    return segment;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-router-cache-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleS5qcyIsIm1hcHBpbmdzIjoiOzs7O3dEQUdnQkE7OztlQUFBQTs7O3FDQUZpQjtBQUUxQixTQUFTQSxxQkFDZEMsT0FBZ0IsRUFDaEJDLHVCQUF3QztJQUF4Q0EsSUFBQUEsNEJBQUFBLEtBQUFBLEdBQUFBLDBCQUFtQztJQUVuQyw4REFBOEQ7SUFDOUQsdUdBQXVHO0lBQ3ZHLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVTtRQUMxQixPQUFPQSxPQUFVLENBQUMsRUFBRSxHQUFDLE1BQUdBLE9BQU8sQ0FBQyxFQUFFLEdBQUMsTUFBR0EsT0FBTyxDQUFDLEVBQUU7SUFDbEQ7SUFFQSxrRUFBa0U7SUFDbEUsa0ZBQWtGO0lBQ2xGLElBQUlDLDJCQUEyQkQsUUFBUUksVUFBVSxDQUFDQyxTQUFBQSxnQkFBZ0IsR0FBRztRQUNuRSxPQUFPQSxTQUFBQSxnQkFBZ0I7SUFDekI7SUFFQSxPQUFPTDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleS50cz9jNTdlIl0sIm5hbWVzIjpbImNyZWF0ZVJvdXRlckNhY2hlS2V5Iiwic2VnbWVudCIsIndpdGhvdXRTZWFyY2hQYXJhbWV0ZXJzIiwiQXJyYXkiLCJpc0FycmF5Iiwic3RhcnRzV2l0aCIsIlBBR0VfU0VHTUVOVF9LRVkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":(module,exports,__webpack_require__)=>{eval('/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "fetchServerResponse", ({\n    enumerable: true,\n    get: function() {\n        return fetchServerResponse;\n    }\n}));\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ "(ssr)/../node_modules/next/dist/client/components/app-router-headers.js");\nconst _approuter = __webpack_require__(/*! ../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ "(ssr)/../node_modules/next/dist/client/app-call-server.js");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ "(ssr)/../node_modules/next/dist/shared/lib/hash.js");\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from \'react-server-dom-webpack/client\'\nconst { createFromFetch } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-server-dom-webpack-client-edge.js") : 0;\nfunction doMpaNavigation(url) {\n    return [\n        (0, _approuter.urlToUrlWithoutFlightMarker)(url).toString(),\n        undefined,\n        false,\n        false\n    ];\n}\nasync function fetchServerResponse(url, flightRouterState, nextUrl, currentBuildId, prefetchKind) {\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: "1",\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it\'s a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = "1";\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    if (false) {}\n    const uniqueCacheQuery = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || "0",\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(","));\n    try {\n        var _res_headers_get;\n        let fetchUrl = new URL(url);\n        if (false) {}\n        // Add unique cache query to avoid caching conflicts on CDN which don\'t respect to Vary header\n        fetchUrl.searchParams.set(_approuterheaders.NEXT_RSC_UNION_QUERY, uniqueCacheQuery);\n        const res = await fetch(fetchUrl, {\n            // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n            credentials: "same-origin",\n            headers\n        });\n        const responseUrl = (0, _approuter.urlToUrlWithoutFlightMarker)(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get("content-type") || "";\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const interception = !!((_res_headers_get = res.headers.get("vary")) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        let isFlightResponse = contentType === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const [buildId, flightData] = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (currentBuildId !== buildId) {\n            return doMpaNavigation(res.url);\n        }\n        return [\n            flightData,\n            canonicalUrl,\n            postponed,\n            interception\n        ];\n    } catch (err) {\n        console.error("Failed to fetch RSC payload for " + url + ". Falling back to browser navigation.", err);\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return [\n            url.toString(),\n            undefined,\n            false,\n            false\n        ];\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs4Q0EyQjRDOzs7NEJBR3BCQSxtQkFBQUEsQ0FBQTtBQTVCeEIsTUFBQUMsUUFBYUQsbUJBQUFBLENBQUE7QUFDYjtBQUNBO0FBQ0Esb0VBR2M7QUErQmQsUUFBQUUsZUFBU0MsRUFBZ0JDLEdBQVcsUUFBQUosbUJBQUFBLENBQUEsMktBQUFBLENBQUE7U0FDbENHLGdCQUFPQyxHQUFBO1dBQUNJO1FBQTZDQyxDQUFBQSxHQUFBQSxXQUFBQSwyQkFBQUEsRUFBQUEsS0FBQUEsUUFBQUE7UUFBV0E7UUFBTztRQUFNO0tBQy9FO0FBS087ZUFPQ0Msb0JBTUZOLEdBQUEsRUFBQU8saUJBQUEsRUFBQUMsT0FBQSxFQUFBQyxjQUFBLEVBQUFDLFlBQUE7VUFDRkosVUFBQTtRQUNBLHlCQUFDSztRQUNELENBQUFDLGtCQUFBRCxVQUFBO1FBQ0EsbUNBQUNFO1FBR0gsQ0FBQUQsa0JBQUFDLHNCQUFBLEdBQUFDLG1CQUFBQyxLQUFBQyxTQUFBLENBQUFUO0lBRUE7Ozs7OztVQU9FRCxpQkFBUVcsb0JBQUFBLFlBQUFBLENBQUFBLElBQTRCLEVBQUc7UUFDekNYLE9BQUEsQ0FBQU0sa0JBQUFLLDJCQUFBO0lBRUE7UUFDRVgsU0FBUVk7UUFDVlosT0FBQSxDQUFBTSxrQkFBQU0sUUFBQSxJQUFBVjtJQUVBO1FBQ0VGLEtBQTZCTCxFQUFBQSxFQUcvQjtVQUVJSyxtQkFBUVcsQ0FBQUEsR0FBQUEsTUFBQUEsT0FBQUEsRUFBQUE7UUFDUlgsT0FBTyxDQUFDTyxrQkFBQUEsMkJBQXVCO1FBQy9CUCxPQUFPLENBQUNZLGtCQUFBQSxzQkFBUztRQUNqQkUsT0FBSyxDQUFBUixrQkFBQU0sUUFBQTtLQUdULENBQUFFLElBQUk7O1FBQ0YsSUFBSUM7UUFDSixJQUFJcEIsV0FBVyxJQUFDcUIsSUFBQUE7WUFDZHJCLEtBQWdCc0IsRUFBb0IsRUFTdEM7UUFDQUYsOEZBQWdESztRQUVoREwsU0FBTU0sWUFBWUMsQ0FBQUEsR0FBTVAsQ0FBQUEsa0JBQVVRLG9CQUFBLEVBQUFIO2NBQ2hDQyxNQUFBLE1BQUFDLE1BQUFQLFVBQUE7WUFDQVMsd0ZBQWE7WUFDYnhCLGFBQUFBO1lBQ0ZBO1FBRUE7UUFDQSxNQUFNeUIsY0FBQUEsQ0FBZUosR0FBQUEsV0FBY3ZCLDJCQUFpQkMsRUFBQUEsSUFBQUEsR0FBQUE7UUFFcEQsTUFBTTJCLGVBQWNMLElBQUlyQixVQUFXLEdBQUMyQixjQUFBNUI7UUFDcEMsTUFBTTZCLGNBQWNQLElBQUlyQixPQUFPLENBQUM2QixHQUFHLENBQUNDLG1CQUFBQTtRQUNwQyxNQUFNQyxZQUFBQSxDQUFBQSxDQUFBQSxJQUFnQi9CLE9BQUNxQixDQUFBQSxHQUFBQSxDQUFBQSxrQkFBSXJCLHdCQUFZO1FBQ3ZDLE1BQUlnQyxlQUFBQSxDQUFBQSxDQUFtQk4sQ0FBQUEsQ0FBQUEsbUJBQWdCTyxJQUFBQSxPQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxPQUFBQSxLQUFBQSxPQUFBQSxLQUF1QixJQUFBQyxpQkFBQUMsUUFBQSxDQUFBN0Isa0JBQUFNLFFBQUE7UUFFOUQsSUFBSWpCLG1CQUFZcUIsZ0JBQWFWLGtCQUFjMkIsdUJBQUE7WUFDekN0QyxLQUFnQnNCLEVBQW9CLEVBT3RDO1FBQ0EsNEZBQW9FO1FBQ3BFLG9FQUFrQztZQUNoQyxDQUFBZSxvQkFBQSxDQUFBWCxJQUFBZ0IsRUFBQTtZQUNBLDJGQUFjO2dCQUNaVixJQUFBQSxJQUFBQSxFQUFBQTtnQkFDRkEsWUFBQVcsSUFBQSxHQUFBNUMsSUFBQTRDLElBQUE7WUFFQTtZQUNGLE9BQUE3QyxnQkFBQWtDLFlBQUFZLFFBQUE7UUFFQTtRQUNBLDJFQUVFO2NBQ0VDLENBQUFBLFNBQUFBLFdBQUFBLEdBQUFBLE1BQUFBLGdCQUFVQyxRQUFBQyxPQUFBLENBQUFyQixNQUFBO1lBQ1ptQixZQUFBRyxlQUFBSCxVQUFBO1FBR0Y7WUFDRXJDLG1CQUFPVixTQUFvQkM7WUFDN0IsT0FBQUQsZ0JBQUE0QixJQUFBM0IsR0FBQTtRQUVBO2VBQVFrRDtZQUFZbkI7WUFBY0c7WUFBV0c7WUFBYUE7U0FDMUQ7YUFDQWMsS0FBUUM7UUFJUkQsUUFBQUMsS0FBQSxzQ0FBaURwRCxNQUFBLHlDQUFBcUQ7UUFDakQ7UUFDQSxxSEFBaUc7UUFDakcsaUdBQU87ZUFBQ3JEO1lBQWdCSyxJQUFBQSxRQUFBQTtZQUFXQTtZQUFPO1lBQU07U0FDbEQ7SUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLnRzP2RlNmQiXSwibmFtZXMiOlsicmVxdWlyZSIsIl9oYXNoIiwiY3JlYXRlRnJvbUZldGNoIiwiZG9NcGFOYXZpZ2F0aW9uIiwidXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInVuZGVmaW5lZCIsImhlYWRlcnMiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJjdXJyZW50QnVpbGRJZCIsInByZWZldGNoS2luZCIsIlJTQ19IRUFERVIiLCJfYXBwcm91dGVyaGVhZGVycyIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9VUkwiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJqb2luIiwiZmV0Y2hVcmwiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsInVuaXF1ZUNhY2hlUXVlcnkiLCJyZXMiLCJmZXRjaCIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwiY3JlZGVudGlhbHMiLCJjYW5vbmljYWxVcmwiLCJjb250ZW50VHlwZSIsInJlc3BvbnNlVXJsIiwicG9zdHBvbmVkIiwiZ2V0IiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwiaW50ZXJjZXB0aW9uIiwiaXNGbGlnaHRSZXNwb25zZSIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiX3Jlc19oZWFkZXJzX2dldCIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsIm9rIiwiaGFzaCIsInRvU3RyaW5nIiwiY2FsbFNlcnZlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiX2FwcGNhbGxzZXJ2ZXIiLCJmbGlnaHREYXRhIiwiY29uc29sZSIsImVycm9yIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "fillCacheWithNewSubTreeData", ({\n    enumerable: true,\n    get: function() {\n        return fillCacheWithNewSubTreeData;\n    }\n}));\nconst _invalidatecachebyrouterstate = __webpack_require__(/*! ./invalidate-cache-by-router-state */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, prefetchEntry) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {\n            const seedData = flightDataPath[3];\n            const rsc = seedData[2];\n            const loading = seedData[3];\n            childCacheNode = {\n                lazyData: null,\n                rsc,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                loading,\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),\n                lazyDataResolved: false\n            };\n            if (existingChildCacheNode) {\n                (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(childCacheNode, existingChildCacheNode, flightDataPath[2], seedData, flightDataPath[4], prefetchEntry);\n            childSegmentMap.set(cacheKey, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: false,\n            loading: childCacheNode.loading\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), prefetchEntry);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7OytEQWFnQkE7OztlQUFBQTs7OzBEQVI2QjsyREFDQztrREFDVDtBQU05QixTQUFTQSw0QkFDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxjQUE4QixFQUM5QkMsYUFBa0M7SUFFbEMsTUFBTUMsY0FBY0YsZUFBZUcsTUFBTSxJQUFJO0lBQzdDLE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdMO0lBRXBDLE1BQU1NLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0Y7SUFFdEMsTUFBTUcsMEJBQ0pULGNBQWNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUVuQyxJQUFJLENBQUNJLHlCQUF5QjtRQUM1Qiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJRyxrQkFBa0JiLFNBQVNXLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUNsRCxJQUFJLENBQUNPLG1CQUFtQkEsb0JBQW9CSCx5QkFBeUI7UUFDbkVHLGtCQUFrQixJQUFJQyxJQUFJSjtRQUMxQlYsU0FBU1csY0FBYyxDQUFDSSxHQUFHLENBQUNULGtCQUFrQk87SUFDaEQ7SUFFQSxNQUFNRyx5QkFBeUJOLHdCQUF3QkUsR0FBRyxDQUFDSjtJQUMzRCxJQUFJUyxpQkFBaUJKLGdCQUFnQkQsR0FBRyxDQUFDSjtJQUV6QyxJQUFJSixhQUFhO1FBQ2YsSUFDRSxDQUFDYSxrQkFDRCxDQUFDQSxlQUFlQyxRQUFRLElBQ3hCRCxtQkFBbUJELHdCQUNuQjtZQUNBLE1BQU1HLFdBQThCakIsY0FBYyxDQUFDLEVBQUU7WUFDckQsTUFBTWtCLE1BQU1ELFFBQVEsQ0FBQyxFQUFFO1lBQ3ZCLE1BQU1FLFVBQVVGLFFBQVEsQ0FBQyxFQUFFO1lBQzNCRixpQkFBaUI7Z0JBQ2ZDLFVBQVU7Z0JBQ1ZFO2dCQUNBRSxhQUFhO2dCQUNiQyxNQUFNO2dCQUNOQyxjQUFjO2dCQUNkSDtnQkFDQSxvRUFBb0U7Z0JBQ3BFVixnQkFBZ0JLLHlCQUNaLElBQUlGLElBQUlFLHVCQUF1QkwsY0FBYyxJQUM3QyxJQUFJRztnQkFDUlcsa0JBQWtCO1lBQ3BCO1lBRUEsSUFBSVQsd0JBQXdCO2dCQUMxQlUsQ0FBQUEsR0FBQUEsOEJBQUFBLDRCQUE0QixFQUMxQlQsZ0JBQ0FELHdCQUNBZCxjQUFjLENBQUMsRUFBRTtZQUVyQjtZQUVBeUIsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUE2QixFQUMzQlYsZ0JBQ0FELHdCQUNBZCxjQUFjLENBQUMsRUFBRSxFQUNqQmlCLFVBQ0FqQixjQUFjLENBQUMsRUFBRSxFQUNqQkM7WUFHRlUsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVTO1FBQ2hDO1FBQ0E7SUFDRjtJQUVBLElBQUksQ0FBQ0Esa0JBQWtCLENBQUNELHdCQUF3QjtRQUM5Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUM3Q0MsaUJBQWlCO1lBQ2ZDLFVBQVVELGVBQWVDLFFBQVE7WUFDakNFLEtBQUtILGVBQWVHLEdBQUc7WUFDdkJFLGFBQWFMLGVBQWVLLFdBQVc7WUFDdkNDLE1BQU1OLGVBQWVNLElBQUk7WUFDekJDLGNBQWNQLGVBQWVPLFlBQVk7WUFDekNiLGdCQUFnQixJQUFJRyxJQUFJRyxlQUFlTixjQUFjO1lBQ3JEYyxrQkFBa0I7WUFDbEJKLFNBQVNKLGVBQWVJLE9BQU87UUFDakM7UUFDQVIsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVTO0lBQ2hDO0lBRUFsQiw0QkFDRWtCLGdCQUNBRCx3QkFDQWQsZUFBZTBCLEtBQUssQ0FBQyxJQUNyQnpCO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLnRzPzQ0MzIiXSwibmFtZXMiOlsiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJwcmVmZXRjaEVudHJ5IiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJzZWVkRGF0YSIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJsYXp5RGF0YVJlc29sdmVkIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "fillLazyItemsTillLeafWithHead", ({\n    enumerable: true,\n    get: function() {\n        return fillLazyItemsTillLeafWithHead;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n        // state tree. Ideally, they would always be the same shape, but because of\n        // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n        // partial tree. That\'s why this node is sometimes null. Once PPR lands,\n        // loading.js will no longer have special behavior and we can traverse the\n        // data tree instead.\n        //\n        // We should also consider merging the router state tree and the data tree\n        // in the response format, so that we don\'t have to send the keys twice.\n        // Then the client can convert them into separate representations.\n        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === "auto" && prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                let newCacheNode;\n                if (parallelSeedData !== null) {\n                    // New data was sent from the server.\n                    const seedNode = parallelSeedData[2];\n                    const loading = parallelSeedData[3];\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: seedNode,\n                        // This is a PPR-only field. When PPR is enabled, we shouldn\'t hit\n                        // this path during a navigation, but until PPR is fully implemented\n                        // yet it\'s possible the existing node does have a non-null\n                        // `prefetchRsc`. As an incremental step, we\'ll just de-opt to the\n                        // old behavior â€” no PPR value.\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        loading,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        lazyDataResolved: false\n                    };\n                } else if (hasReusablePrefetch && existingCacheNode) {\n                    // No new data was sent from the server, but the existing cache node\n                    // was prefetched, so we should reuse that.\n                    newCacheNode = {\n                        lazyData: existingCacheNode.lazyData,\n                        rsc: existingCacheNode.rsc,\n                        // This is a PPR-only field. Unlike the previous branch, since we\'re\n                        // just cloning the existing cache node, we might as well keep the\n                        // PPR value, if it exists.\n                        prefetchRsc: existingCacheNode.prefetchRsc,\n                        head: existingCacheNode.head,\n                        prefetchHead: existingCacheNode.prefetchHead,\n                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n                        lazyDataResolved: existingCacheNode.lazyDataResolved,\n                        loading: existingCacheNode.loading\n                    };\n                } else {\n                    // No data available for this node. This will trigger a lazy fetch\n                    // during render.\n                    newCacheNode = {\n                        lazyData: null,\n                        rsc: null,\n                        prefetchRsc: null,\n                        head: null,\n                        prefetchHead: null,\n                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),\n                        lazyDataResolved: false,\n                        loading: null\n                    };\n                }\n                // Overrides the cache key with the new cache node.\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                // Traverse deeper to apply the head / fill lazy items till the head.\n                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        let newCacheNode;\n        if (parallelSeedData !== null) {\n            // New data was sent from the server.\n            const seedNode = parallelSeedData[2];\n            const loading = parallelSeedData[3];\n            newCacheNode = {\n                lazyData: null,\n                rsc: seedNode,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading\n            };\n        } else {\n            // No data available for this node. This will trigger a lazy fetch\n            // during render.\n            newCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                lazyDataResolved: false,\n                loading: null\n            };\n        }\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC5qcyIsIm1hcHBpbmdzIjoiOzs7O2lFQVdnQkE7OztlQUFBQTs7O2tEQU5xQjtnREFJOUI7QUFFQSxTQUFTQSw4QkFDZEMsUUFBbUIsRUFDbkJDLGFBQW9DLEVBQ3BDQyxXQUE4QixFQUM5QkMsaUJBQTJDLEVBQzNDQyxJQUFxQixFQUNyQkMsYUFBa0M7SUFFbEMsTUFBTUMsZ0JBQWdCQyxPQUFPQyxJQUFJLENBQUNOLFdBQVcsQ0FBQyxFQUFFLEVBQUVPLE1BQU0sS0FBSztJQUM3RCxJQUFJSCxlQUFlO1FBQ2pCTixTQUFTSSxJQUFJLEdBQUdBO1FBQ2hCO0lBQ0Y7SUFDQSx1RkFBdUY7SUFDdkYsSUFBSyxNQUFNTSxPQUFPUixXQUFXLENBQUMsRUFBRSxDQUFFO1FBQ2hDLE1BQU1TLHFCQUFxQlQsV0FBVyxDQUFDLEVBQUUsQ0FBQ1EsSUFBSTtRQUM5QyxNQUFNRSwwQkFBMEJELGtCQUFrQixDQUFDLEVBQUU7UUFDckQsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtRQUV0Qyw0RUFBNEU7UUFDNUUsMkVBQTJFO1FBQzNFLHdFQUF3RTtRQUN4RSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLHFCQUFxQjtRQUNyQixFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxrRUFBa0U7UUFDbEUsTUFBTUcsbUJBQ0paLHNCQUFzQixRQUFRQSxpQkFBaUIsQ0FBQyxFQUFFLENBQUNPLElBQUksS0FBS00sWUFDeERiLGlCQUFpQixDQUFDLEVBQUUsQ0FBQ08sSUFBSSxHQUN6QjtRQUNOLElBQUlULGVBQWU7WUFDakIsTUFBTWdCLGtDQUNKaEIsY0FBY2lCLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDVDtZQUNuQyxJQUFJTyxpQ0FBaUM7Z0JBQ25DLE1B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QXVCRCxHQUFHLENBQUN2QixVQUFVZTtRQUN2QyxPQUFPO1lBQ0w1QixTQUFTa0IsY0FBYyxDQUFDa0IsR0FBRyxDQUFDMUIsS0FBSyxJQUFJZ0IsSUFBSTtnQkFBQztvQkFBQ2I7b0JBQVVlO2lCQUFhO2FBQUM7UUFDckU7UUFFQTdCLDhCQUNFNkIsY0FDQVosV0FDQUwsb0JBQ0FJLGtCQUNBWCxNQUNBQztJQUVKO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzPzNmODUiXSwibmFtZXMiOlsiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJuZXdDYWNoZSIsImV4aXN0aW5nQ2FjaGUiLCJyb3V0ZXJTdGF0ZSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsInByZWZldGNoRW50cnkiLCJpc0xhc3RTZWdtZW50IiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImtleSIsInBhcmFsbGVsUm91dGVTdGF0ZSIsInNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlIiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsInBhcmFsbGVsU2VlZERhdGEiLCJ1bmRlZmluZWQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJoYXNSZXVzYWJsZVByZWZldGNoIiwia2luZCIsInN0YXR1cyIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsInJldXNhYmxlIiwicGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSIsIk1hcCIsImV4aXN0aW5nQ2FjaGVOb2RlIiwibmV3Q2FjaGVOb2RlIiwic2VlZE5vZGUiLCJsb2FkaW5nIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsInByZWZldGNoSGVhZCIsImxhenlEYXRhUmVzb2x2ZWQiLCJzZXQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "handleMutable", ({\n    enumerable: true,\n    get: function() {\n        return handleMutable;\n    }\n}));\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js");\nfunction isNotUndefined(value) {\n    return typeof value !== "undefined";\n}\nfunction handleMutable(state, mutable) {\n    var _mutable_canonicalUrl;\n    var _mutable_shouldScroll;\n    // shouldScroll is true by default, can override to false.\n    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;\n    let nextUrl = state.nextUrl;\n    if (isNotUndefined(mutable.patchedTree)) {\n        // If we received a patched tree, we need to compute the changed path.\n        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);\n        if (changedPath) {\n            // If the tree changed, we need to update the nextUrl\n            nextUrl = changedPath;\n        } else if (!nextUrl) {\n            // if the tree ends up being the same (ie, no changed path), and we don\'t have a nextUrl, then we should use the canonicalUrl\n            nextUrl = state.canonicalUrl;\n        }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n    }\n    var _mutable_scrollableSegments;\n    return {\n        buildId: state.buildId,\n        // Set href.\n        canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,\n            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: shouldScroll ? isNotUndefined(mutable == null ? void 0 : mutable.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,\n            onlyHashChange: !!mutable.hashFragment && state.canonicalUrl.split("#", 1)[0] === ((_mutable_canonicalUrl = mutable.canonicalUrl) == null ? void 0 : _mutable_canonicalUrl.split("#", 1)[0]),\n            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== "" ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,\n            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,\n        // Apply patched router state.\n        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,\n        nextUrl\n    };\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-mutable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtbXV0YWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQVdnQkE7OztlQUFBQTs7O2dEQVhtQjtBQU9uQyxTQUFTQyxlQUFrQkMsS0FBUTtJQUNqQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUI7QUFFTyxTQUFTRixjQUNkRyxLQUEyQixFQUMzQkMsT0FBZ0I7UUFvRFJBO1FBakRhQTtJQURyQiwwREFBMEQ7SUFDMUQsTUFBTUMsZUFBZUQsQ0FBQUEsd0JBQUFBLFFBQVFDLFlBQVksWUFBcEJELHdCQUF3QjtJQUU3QyxJQUFJRSxVQUFVSCxNQUFNRyxPQUFPO0lBRTNCLElBQUlMLGVBQWVHLFFBQVFHLFdBQVcsR0FBRztRQUN2QyxzRUFBc0U7UUFDdEUsTUFBTUMsY0FBY0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFrQixFQUFDTixNQUFNTyxJQUFJLEVBQUVOLFFBQVFHLFdBQVc7UUFDdEUsSUFBSUMsYUFBYTtZQUNmLHFEQUFxRDtZQUNyREYsVUFBVUU7UUFDWixPQUFPLElBQUksQ0FBQ0YsU0FBUztZQUNuQiw2SEFBNkg7WUFDN0hBLFVBQVVILE1BQU1RLFlBQVk7UUFDOUI7SUFDQSwwRUFBMEU7SUFDNUU7UUE2Q1FQO0lBM0NSLE9BQU87UUFDTFEsU0FBU1QsTUFBTVMsT0FBTztRQUN0QixZQUFZO1FBQ1pELGNBQWNWLGVBQWVHLFFBQVFPLFlBQVksSUFDN0NQLFFBQVFPLFlBQVksS0FBS1IsTUFBTVEsWUFBWSxHQUN6Q1IsTUFBTVEsWUFBWSxHQUNsQlAsUUFBUU8sWUFBWSxHQUN0QlIsTUFBTVEsWUFBWTtRQUN0QkUsU0FBUztZQUNQQyxhQUFhYixlQUFlRyxRQUFRVSxXQUFXLElBQzNDVixRQUFRVSxXQUFXLEdBQ25CWCxNQUFNVSxPQUFPLENBQUNDLFdBQVc7WUFDN0JDLGVBQWVkLGVBQWVHLFFBQVFXLGFBQWEsSUFDL0NYLFFBQVFXLGFBQWEsR0FDckJaLE1BQU1VLE9BQU8sQ0FBQ0UsYUFBYTtZQUMvQkMsNEJBQTRCZixlQUMxQkcsUUFBUVksMEJBQTBCLElBRWhDWixRQUFRWSwwQkFBMEIsR0FDbENiLE1BQU1VLE9BQU8sQ0FBQ0csMEJBQTBCO1FBQzlDO1FBQ0Esa0VBQWtFO1FBQ2xFQyxtQkFBbUI7WUFDakJDLE9BQU9iLGVBQ0hKLGVBQWVHLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNlLGtCQUFrQixJQUN4QyxPQUNBaEIsTUFBTWMsaUJBQWlCLENBQUNDLEtBQUssR0FFL0I7WUFDSkUsZ0JBQ0UsQ0FBQyxDQUFDaEIsUUFBUWlCLFlBQVksSUFDdEJsQixNQUFNUSxZQUFZLENBQUNXLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLE9BQ2pDbEIsd0JBQUFBLFFBQVFPLFlBQVkscUJBQXBCUCxzQkFBc0JrQixLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtZQUMxQ0QsY0FBY2hCLGVBR1ZELFFBQVFpQixZQUFZLElBQUlqQixRQUFRaUIsWUFBWSxLQUFLLEtBRS9DRSxtQkFBbUJuQixRQUFRaUIsWUFBWSxDQUFDRyxLQUFLLENBQUMsTUFDOUNyQixNQUFNYyxpQkFBaUIsQ0FBQ0ksWUFBWSxHQUV0QztZQUNKSSxjQUFjcEIsZUFDVkQsQ0FBQUEsOEJBQUFBLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNlLGtCQUFrQixZQUEzQmYsOEJBQStCRCxNQUFNYyxpQkFBaUIsQ0FBQ1EsWUFBWSxHQUVuRSxFQUFFO1FBQ1I7UUFDQSxlQUFlO1FBQ2ZDLE9BQU90QixRQUFRc0IsS0FBSyxHQUFHdEIsUUFBUXNCLEtBQUssR0FBR3ZCLE1BQU11QixLQUFLO1FBQ2xEQyxlQUFldkIsUUFBUXVCLGFBQWEsR0FDaEN2QixRQUFRdUIsYUFBYSxHQUNyQnhCLE1BQU13QixhQUFhO1FBQ3ZCLDhCQUE4QjtRQUM5QmpCLE1BQU1ULGVBQWVHLFFBQVFHLFdBQVcsSUFDcENILFFBQVFHLFdBQVcsR0FDbkJKLE1BQU1PLElBQUk7UUFDZEo7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtbXV0YWJsZS50cz9mZmY4Il0sIm5hbWVzIjpbImhhbmRsZU11dGFibGUiLCJpc05vdFVuZGVmaW5lZCIsInZhbHVlIiwic3RhdGUiLCJtdXRhYmxlIiwic2hvdWxkU2Nyb2xsIiwibmV4dFVybCIsInBhdGNoZWRUcmVlIiwiY2hhbmdlZFBhdGgiLCJjb21wdXRlQ2hhbmdlZFBhdGgiLCJ0cmVlIiwiY2Fub25pY2FsVXJsIiwiYnVpbGRJZCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiYXBwbHkiLCJzY3JvbGxhYmxlU2VnbWVudHMiLCJvbmx5SGFzaENoYW5nZSIsImhhc2hGcmFnbWVudCIsInNwbGl0IiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2xpY2UiLCJzZWdtZW50UGF0aHMiLCJjYWNoZSIsInByZWZldGNoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "handleSegmentMismatch", ({\n    enumerable: true,\n    get: function() {\n        return handleSegmentMismatch;\n    }\n}));\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nfunction handleSegmentMismatch(state, action, treePatch) {\n    if (true) {\n        console.warn("Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n" + "Reason: Segment mismatch\\n" + ("Last Action: " + action.type + "\\n\\n") + ("Current Tree: " + JSON.stringify(state.tree) + "\\n\\n") + ("Tree Patch Payload: " + JSON.stringify(treePatch)));\n    }\n    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-segment-mismatch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtc2VnbWVudC1taXNtYXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lEQVdnQkE7OztlQUFBQTs7OzZDQVZrQjtBQVUzQixTQUFTQSxzQkFDZEMsS0FBMkIsRUFDM0JDLE1BQXNCLEVBQ3RCQyxTQUE0QjtJQUU1QixJQUFJQyxJQUF5QixFQUFlO1FBQzFDQyxRQUFRQyxJQUFJLENBQ1Ysc0pBQ0UsK0JBQ0EsbUJBQWdCSixPQUFPSyxJQUFJLEdBQUMsVUFDNUIsb0JBQWlCQyxLQUFLQyxTQUFTLENBQUNSLE1BQU1TLElBQUksSUFBRSxVQUM1QywwQkFBdUJGLEtBQUtDLFNBQVMsQ0FBQ04sVUFBQUE7SUFFNUM7SUFFQSxPQUFPUSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQUNWLE9BQU8sQ0FBQyxHQUFHQSxNQUFNVyxZQUFZLEVBQUU7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoLnRzP2I4MDMiXSwibmFtZXMiOlsiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwic3RhdGUiLCJhY3Rpb24iLCJ0cmVlUGF0Y2giLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJ0eXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJoYW5kbGVFeHRlcm5hbFVybCIsImNhbm9uaWNhbFVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "invalidateCacheBelowFlightSegmentPath", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheBelowFlightSegmentPath;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don\'t copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(cacheKey);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);\n    let childCacheNode = childSegmentMap.get(cacheKey);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            lazyData: childCacheNode.lazyData,\n            rsc: childCacheNode.rsc,\n            prefetchRsc: childCacheNode.prefetchRsc,\n            head: childCacheNode.head,\n            prefetchHead: childCacheNode.prefetchHead,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes),\n            lazyDataResolved: childCacheNode.lazyDataResolved\n        };\n        childSegmentMap.set(cacheKey, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lFQU9nQkE7OztlQUFBQTs7O2tEQUxxQjtBQUs5QixTQUFTQSxzQ0FDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxpQkFBb0M7SUFFcEMsTUFBTUMsY0FBY0Qsa0JBQWtCRSxNQUFNLElBQUk7SUFDaEQsTUFBTSxDQUFDQyxrQkFBa0JDLFFBQVEsR0FBR0o7SUFFcEMsTUFBTUssV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtJQUV0QyxNQUFNRywwQkFDSlIsY0FBY1MsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBRW5DLElBQUksQ0FBQ0kseUJBQXlCO1FBQzVCLDZFQUE2RTtRQUM3RSxzRUFBc0U7UUFDdEU7SUFDRjtJQUVBLElBQUlHLGtCQUFrQlosU0FBU1UsY0FBYyxDQUFDQyxHQUFHLENBQUNOO0lBQ2xELElBQUksQ0FBQ08sbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNuRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVCxTQUFTVSxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Qsa0JBQWtCTztJQUNoRDtJQUVBLGlEQUFpRDtJQUNqRCxJQUFJVCxhQUFhO1FBQ2ZTLGdCQUFnQkcsTUFBTSxDQUFDUjtRQUN2QjtJQUNGO0lBRUEsTUFBTVMseUJBQXlCUCx3QkFBd0JFLEdBQUcsQ0FBQ0o7SUFDM0QsSUFBSVUsaUJBQWlCTCxnQkFBZ0JELEdBQUcsQ0FBQ0o7SUFFekMsSUFBSSxDQUFDVSxrQkFBa0IsQ0FBQ0Qsd0JBQXdCO1FBQzlDLDZFQUE2RTtRQUM3RSxzRUFBc0U7UUFDdEU7SUFDRjtJQUVBLElBQUlDLG1CQUFtQkQsd0JBQXdCO1FBQzdDQyxpQkFBaUI7WUFDZkMsVUFBVUQsZUFBZUMsUUFBUTtZQUNqQ0MsS0FBS0YsZUFBZUUsR0FBRztZQUN2QkMsYUFBYUgsZUFBZUcsV0FBVztZQUN2Q0MsTUFBTUosZUFBZUksSUFBSTtZQUN6QkMsY0FBY0wsZUFBZUssWUFBWTtZQUN6Q1osZ0JBQWdCLElBQUlHLElBQUlJLGVBQWVQLGNBQWM7WUFDckRhLGtCQUFrQk4sZUFBZU0sZ0JBQWdCO1FBQ25EO1FBQ0FYLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVVTtJQUNoQztJQUVBbEIsc0NBQ0VrQixnQkFDQUQsd0JBQ0FkLGtCQUFrQnNCLEtBQUssQ0FBQztBQUU1QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGgudHM/YmU4MyJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJkZWxldGUiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImxhenlEYXRhUmVzb2x2ZWQiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "invalidateCacheByRouterState", ({\n    enumerable: true,\n    get: function() {\n        return invalidateCacheByRouterState;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of rsc.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-by-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2dFQU9nQkE7OztlQUFBQTs7O2tEQUxxQjtBQUs5QixTQUFTQSw2QkFDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxXQUE4QjtJQUU5Qix1RkFBdUY7SUFDdkYsSUFBSyxNQUFNQyxPQUFPRCxXQUFXLENBQUMsRUFBRSxDQUFFO1FBQ2hDLE1BQU1FLDBCQUEwQkYsV0FBVyxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEVBQUU7UUFDdEQsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtRQUN0QyxNQUFNRyxrQ0FDSk4sY0FBY08sY0FBYyxDQUFDQyxHQUFHLENBQUNOO1FBQ25DLElBQUlJLGlDQUFpQztZQUNuQyxJQUFJRyx5QkFBeUIsSUFBSUMsSUFBSUo7WUFDckNHLHVCQUF1QkUsTUFBTSxDQUFDUDtZQUM5QkwsU0FBU1EsY0FBYyxDQUFDSyxHQUFHLENBQUNWLEtBQUtPO1FBQ25DO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUudHM/ZjViMSJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "isNavigatingToNewRootLayout", ({\n    enumerable: true,\n    get: function() {\n        return isNavigatingToNewRootLayout;\n    }\n}));\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is \'same\' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn\'t have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn\'t have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can\'t assume it\'s `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it\'s not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7OytEQUVnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsNEJBQ2RDLFdBQThCLEVBQzlCQyxRQUEyQjtJQUUzQixtQkFBbUI7SUFDbkIsTUFBTUMscUJBQXFCRixXQUFXLENBQUMsRUFBRTtJQUN6QyxNQUFNRyxrQkFBa0JGLFFBQVEsQ0FBQyxFQUFFO0lBRW5DLDJGQUEyRjtJQUMzRiw0REFBNEQ7SUFDNUQsdUlBQXVJO0lBQ3ZJLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0gsdUJBQXVCRSxNQUFNQyxPQUFPLENBQUNGLGtCQUFrQjtRQUN2RSxzSEFBc0g7UUFDdEgsdUdBQXVHO1FBQ3ZHLElBQ0VELGtCQUFrQixDQUFDLEVBQUUsS0FBS0MsZUFBZSxDQUFDLEVBQUUsSUFDNUNELGtCQUFrQixDQUFDLEVBQUUsS0FBS0MsZUFBZSxDQUFDLEVBQUUsRUFDNUM7WUFDQSxPQUFPO1FBQ1Q7SUFDRixPQUFPLElBQUlELHVCQUF1QkMsaUJBQWlCO1FBQ2pELE9BQU87SUFDVDtJQUVBLGlDQUFpQztJQUNqQyxJQUFJSCxXQUFXLENBQUMsRUFBRSxFQUFFO1FBQ2xCLDRFQUE0RTtRQUM1RSxPQUFPLENBQUNDLFFBQVEsQ0FBQyxFQUFFO0lBQ3JCO0lBQ0EscUVBQXFFO0lBQ3JFLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEVBQUU7UUFDZixPQUFPO0lBQ1Q7SUFDQSw0R0FBNEc7SUFDNUcsMkZBQTJGO0lBQzNGLG1EQUFtRDtJQUNuRCxNQUFNSyxtQkFBbUJDLE9BQU9DLE1BQU0sQ0FBQ1IsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDekQsTUFBTVMsZ0JBQWdCRixPQUFPQyxNQUFNLENBQUNQLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ25ELElBQUksQ0FBQ0ssb0JBQW9CLENBQUNHLGVBQWUsT0FBTztJQUNoRCxPQUFPViw0QkFBNEJPLGtCQUFrQkc7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0LnRzPzQ1Y2MiXSwibmFtZXMiOlsiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImN1cnJlbnRUcmVlQ2hpbGQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":(module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    updateCacheNodeOnNavigation: function() {\n        return updateCacheNodeOnNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(ssr)/../node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(ssr)/../node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server â€” for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.PAGE_SEGMENT_KEY) {\n            // This is a leaf segment â€” a page, not a shared layout. We always apply\n            // its data.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        } else if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment â€” a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation â€” but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else if (oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees.\n                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n                    // Recursively update the children.\n                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);\n                } else {\n                    // The server didn't send any prefetch data for this segment. This\n                    // shouldn't happen because the Route Tree and the Seed Data tree\n                    // should always be the same shape, but until we unify those types\n                    // it's still possible. For now we're going to deopt and trigger a\n                    // lazy fetch during render.\n                    taskChild = spawnTaskForMissingData(newRouterStateChild);\n                }\n            } else {\n                // Either there's no existing Cache Node for this segment, or this\n                // segment doesn't exist in the old Router State tree. Switch to the\n                // \"create\" path.\n                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);\n        }\n        if (taskChild !== null) {\n            // Something changed in the child tree. Keep track of the child task.\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes,\n        lazyDataResolved: false\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead) {\n    // Create a task that will later be fulfilled by data from the server.\n    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        children: null\n    };\n}\nfunction spawnTaskForMissingData(routerState) {\n    // Create a task for a new subtree that wasn't prefetched by the server.\n    // This shouldn't really ever happen but it's here just in case the Seed Data\n    // Tree and the Router State Tree disagree unexpectedly.\n    const pendingCacheNode = createPendingCacheNode(routerState, null, null);\n    return {\n        route: routerState,\n        node: pendingCacheNode,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((response)=>{\n        const flightData = response[0];\n        for (const flightDataPath of flightData){\n            const segmentPath = flightDataPath.slice(0, -3);\n            const serverRouterState = flightDataPath[flightDataPath.length - 3];\n            const dynamicData = flightDataPath[flightDataPath.length - 2];\n            const dynamicHead = flightDataPath[flightDataPath.length - 1];\n            if (typeof segmentPath === \"string\") {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Null this out to indicate that the task is complete.\n            task.node = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[1];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : null,\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null,\n        lazyDataResolved: false\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety â€” it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[1];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[2];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Null this out to indicate that the task is complete.\n    task.node = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch  data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === \"pending\";\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes,\n        lazyDataResolved: false\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = \"pending\";\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === \"pending\") {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = \"fulfilled\";\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === \"pending\") {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = \"rejected\";\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcHItbmF2aWdhdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBMm5CZ0JBLFdBQVM7ZUFBVEE7O0lBblRBQyx5QkFBdUI7ZUFBdkJBOztJQXhRQUMsNkJBQTJCO2VBQTNCQTs7SUF1b0JBQyxzQ0FBb0M7ZUFBcENBOzs7cUNBenJCVDsyQ0FDc0I7a0RBQ1E7QUFnRDlCLFNBQVNELDRCQUNkRSxZQUF1QixFQUN2QkMsY0FBaUMsRUFDakNDLGNBQWlDLEVBQ2pDQyxZQUErQixFQUMvQkMsWUFBNkI7SUFFN0IsMERBQTBEO0lBQzFELE1BQU1DLHlCQUF5QkosY0FBYyxDQUFDLEVBQUU7SUFDaEQsTUFBTUsseUJBQXlCSixjQUFjLENBQUMsRUFBRTtJQUNoRCxNQUFNSyx1QkFBdUJKLFlBQVksQ0FBQyxFQUFFO0lBRTVDLE1BQU1LLG9CQUFvQlIsYUFBYVMsY0FBYztJQUVyRCwyRUFBMkU7SUFDM0UsZ0JBQWdCO0lBQ2hCLDBFQUEwRTtJQUMxRSwwRUFBMEU7SUFDMUUsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSwwRUFBMEU7SUFDMUUsdUVBQXVFO0lBQ3ZFLHlFQUF5RTtJQUN6RSx3RUFBd0U7SUFDeEUsK0JBQStCO0lBQy9CLE1BQU1DLHlCQUF5QixJQUFJQyxJQUFJSDtJQUV2Qyw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSw2RUFBNkU7SUFDN0UsbUJBQW1CO0lBQ25CLElBQUlJLDZCQUVBLENBQUM7SUFDTCxJQUFJQyxlQUFlO0lBQ25CLElBQUssSUFBSUMsb0JBQW9CUix1QkFBd0I7UUFDbkQsTUFBTVMsc0JBQ0pULHNCQUFzQixDQUFDUSxpQkFBaUI7UUFDMUMsTUFBTUUsc0JBQ0pYLHNCQUFzQixDQUFDUyxpQkFBaUI7UUFDMUMsTUFBTUcscUJBQXFCVCxrQkFBa0JVLEdBQUcsQ0FBQ0o7UUFDakQsTUFBTUssb0JBQ0paLG9CQUFvQixDQUFDTyxpQkFBaUI7UUFFeEMsTUFBTU0sa0JBQWtCTCxtQkFBbUIsQ0FBQyxFQUFFO1FBQzlDLE1BQU1NLHFCQUFxQkMsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtRQUVoRCxNQUFNRyxrQkFDSlAsd0JBQXdCUSxZQUFZUixtQkFBbUIsQ0FBQyxFQUFFLEdBQUdRO1FBRS9ELE1BQU1DLG9CQUNKUix1QkFBdUJPLFlBQ25CUCxtQkFBbUJDLEdBQUcsQ0FBQ0csc0JBQ3ZCRztRQUVOLElBQUlFO1FBQ0osSUFBSU4sb0JBQW9CTyxTQUFBQSxnQkFBZ0IsRUFBRTtZQUN4Qyx3RUFBd0U7WUFDeEUsWUFBWTtZQUNaRCxZQUFZRSxpQkFDVmIscUJBQ0FJLHNCQUFzQkssWUFBWUwsb0JBQW9CLE1BQ3REZjtRQUVKLE9BQU8sSUFBSWdCLG9CQUFvQlMsU0FBQUEsbUJBQW1CLEVBQUU7WUFDbEQsMERBQTBEO1lBQzFELEVBQUU7WUFDRix5RUFBeUU7WUFDekUsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSxvRUFBb0U7WUFDcEUsV0FBVztZQUNYLElBQUliLHdCQUF3QlEsV0FBVztnQkFDckMsc0VBQXNFO2dCQUN0RSxvRUFBb0U7Z0JBQ3BFLG1FQUFtRTtnQkFDbkVFLFlBQVlJLGdCQUFnQmQ7WUFDOUIsT0FBTztnQkFDTCxvRUFBb0U7Z0JBQ3BFVSxZQUFZRSxpQkFDVmIscUJBQ0FJLHNCQUFzQkssWUFBWUwsb0JBQW9CLE1BQ3REZjtZQUVKO1FBQ0YsT0FBTyxJQUNMbUIsb0JBQW9CQyxhQUNwQk8sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDWCxpQkFBaUJHLGtCQUM5QjtZQUNBLElBQ0VFLHNCQUFzQkQsYUFDdEJSLHdCQUF3QlEsV0FDeEI7Z0JBQ0EscURBQXFEO2dCQUNyRCxJQUFJTCxzQkFBc0JLLGFBQWFMLHNCQUFzQixNQUFNO29CQUNqRSxtQ0FBbUM7b0JBQ25DTyxZQUFZNUIsNEJBQ1YyQixtQkFDQVQscUJBQ0FELHFCQUNBSSxtQkFDQWY7Z0JBRUosT0FBTztvQkFDTCxrRUFBa0U7b0JBQ2xFLGlFQUFpRTtvQkFDakUsa0VBQWtFO29CQUNsRSxrRUFBa0U7b0JBQ2xFLDRCQUE0QjtvQkFDNUJzQixZQUFZTSx3QkFBd0JqQjtnQkFDdEM7WUFDRixPQUFPO2dCQUNMLGtFQUFrRTtnQkFDbEUsb0VBQW9FO2dCQUNwRSxpQkFBaUI7Z0JBQ2pCVyxZQUFZRSxpQkFDVmIscUJBQ0FJLHNCQUFzQkssWUFBWUwsb0JBQW9CLE1BQ3REZjtZQUVKO1FBQ0YsT0FBTztZQUNMLG1EQUFtRDtZQUNuRHNCLFlBQVlFLGlCQUNWYixxQkFDQUksc0JBQXNCSyxZQUFZTCxvQkFBb0IsTUFDdERmO1FBRUo7UUFFQSxJQUFJc0IsY0FBYyxNQUFNO1lBQ3RCLHFFQUFxRTtZQUNyRSxJQUFJYixpQkFBaUIsTUFBTTtnQkFDekJBLGVBQWUsSUFBSUY7WUFDckI7WUFDQUUsYUFBYW9CLEdBQUcsQ0FBQ25CLGtCQUFrQlk7WUFDbkMsTUFBTVEsb0JBQW9CUixVQUFVUyxJQUFJO1lBQ3hDLElBQUlELHNCQUFzQixNQUFNO2dCQUM5QixNQUFNRSxxQkFBc0MsSUFBSXpCLElBQUlNO2dCQUNwRG1CLG1CQUFtQkgsR0FBRyxDQUFDWixvQkFBb0JhO2dCQUMzQ3hCLHVCQUF1QnVCLEdBQUcsQ0FBQ25CLGtCQUFrQnNCO1lBQy9DO1lBRUEsb0VBQW9FO1lBQ3BFLHVFQUF1RTtZQUN2RSxZQUFZO1lBQ1p4QiwwQkFBMEIsQ0FBQ0UsaUJBQWlCLEdBQUdZLFVBQVVXLEtBQUs7UUFDaEUsT0FBTztZQUNMLG1FQUFtRTtZQUNuRXpCLDBCQUEwQixDQUFDRSxpQkFBaUIsR0FBR0M7UUFDakQ7SUFDRjtJQUVBLElBQUlGLGlCQUFpQixNQUFNO1FBQ3pCLDZCQUE2QjtRQUM3QixPQUFPO0lBQ1Q7SUFFQSxNQUFNeUIsZUFBK0I7UUFDbkNDLFVBQVU7UUFDVkMsS0FBS3hDLGFBQWF3QyxHQUFHO1FBQ3JCLDBFQUEwRTtRQUMxRSxxRUFBcUU7UUFDckUsMkVBQTJFO1FBQzNFLDBFQUEwRTtRQUMxRSwyRUFBMkU7UUFDM0UscUNBQXFDO1FBQ3JDQyxhQUFhekMsYUFBYXlDLFdBQVc7UUFDckNDLE1BQU0xQyxhQUFhMEMsSUFBSTtRQUN2QnRDLGNBQWNKLGFBQWFJLFlBQVk7UUFDdkN1QyxTQUFTM0MsYUFBYTJDLE9BQU87UUFFN0IseUVBQXlFO1FBQ3pFbEMsZ0JBQWdCQztRQUNoQmtDLGtCQUFrQjtJQUNwQjtJQUVBLE9BQU87UUFDTCxrRUFBa0U7UUFDbEVQLE9BQU9RLGdDQUNMM0MsZ0JBQ0FVO1FBRUZ1QixNQUFNRztRQUNOUSxVQUFVakM7SUFDWjtBQUNGO0FBRUEsU0FBU2dDLGdDQUNQRSxlQUFrQyxFQUNsQ0MsV0FBOEQ7SUFFOUQsTUFBTUMsUUFBMkI7UUFBQ0YsZUFBZSxDQUFDLEVBQUU7UUFBRUM7S0FBWTtJQUNsRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLHVDQUF1QztJQUN2QyxJQUFJLEtBQUtELGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxJQUFJLEtBQUtBLGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxJQUFJLEtBQUtBLGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxPQUFPRTtBQUNUO0FBRUEsU0FBU3JCLGlCQUNQc0IsV0FBOEIsRUFDOUIvQyxZQUFzQyxFQUN0Q0MsWUFBNkI7SUFFN0Isc0VBQXNFO0lBQ3RFLE1BQU0rQyxtQkFBbUJDLHVCQUN2QkYsYUFDQS9DLGNBQ0FDO0lBRUYsT0FBTztRQUNMaUMsT0FBT2E7UUFDUGYsTUFBTWdCO1FBQ05MLFVBQVU7SUFDWjtBQUNGO0FBRUEsU0FBU2hCLGdCQUFnQnVCLGlCQUFvQztJQUMzRCxtRUFBbUU7SUFDbkUsMERBQTBEO0lBQzFELE9BQU87UUFDTGhCLE9BQU9nQjtRQUNQbEIsTUFBTTtRQUNOVyxVQUFVO0lBQ1o7QUFDRjtBQUVBLFNBQVNkLHdCQUF3QmtCLFdBQThCO0lBQzdELHdFQUF3RTtJQUN4RSw2RUFBNkU7SUFDN0Usd0RBQXdEO0lBQ3hELE1BQU1DLG1CQUFtQkMsdUJBQXVCRixhQUFhLE1BQU07SUFDbkUsT0FBTztRQUNMYixPQUFPYTtRQUNQZixNQUFNZ0I7UUFDTkwsVUFBVTtJQUNaO0FBQ0Y7QUFpQk8sU0FBU2pELHdCQUNkeUQsSUFBVSxFQUNWQyxlQUFtRDtJQUVuREEsZ0JBQWdCQyxJQUFJLENBQ2xCLENBQUNDO1FBQ0MsTUFBTUMsYUFBYUQsUUFBUSxDQUFDLEVBQUU7UUFDOUIsS0FBSyxNQUFNRSxrQkFBa0JELFdBQVk7WUFDdkMsTUFBTUUsY0FBY0QsZUFBZUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUM3QyxNQUFNQyxvQkFBb0JILGNBQWMsQ0FBQ0EsZUFBZUksTUFBTSxHQUFHLEVBQUU7WUFDbkUsTUFBTUMsY0FBY0wsY0FBYyxDQUFDQSxlQUFlSSxNQUFNLEdBQUcsRUFBRTtZQUM3RCxNQUFNRSxjQUFjTixjQUFjLENBQUNBLGVBQWVJLE1BQU0sR0FBRyxFQUFFO1lBRTdELElBQUksT0FBT0gsZ0JBQWdCLFVBQVU7Z0JBSW5DO1lBQ0Y7WUFFQU0sZ0NBQ0VaLE1BQ0FNLGFBQ0FFLG1CQUNBRSxhQUNBQztRQUVKO1FBRUEsd0VBQXdFO1FBQ3hFLHFFQUFxRTtRQUNyRSw2REFBNkQ7UUFDN0RyRSxVQUFVMEQsTUFBTTtJQUNsQixHQUNBLENBQUNhO1FBQ0MsMkNBQTJDO1FBQzNDdkUsVUFBVTBELE1BQU1hO0lBQ2xCO0FBRUo7QUFFQSxTQUFTRCxnQ0FDUEUsUUFBYyxFQUNkUixXQUE4QixFQUM5QkUsaUJBQW9DLEVBQ3BDRSxXQUE4QixFQUM5QkMsV0FBNEI7SUFFNUIsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxxQ0FBcUM7SUFDckMsRUFBRTtJQUNGLDhFQUE4RTtJQUM5RSxxQ0FBcUM7SUFDckMsRUFBRTtJQUNGLDZEQUE2RDtJQUM3RCxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLElBQUlYLE9BQU9jO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlULFlBQVlHLE1BQU0sRUFBRU0sS0FBSyxFQUFHO1FBQzlDLE1BQU12RCxtQkFBMkI4QyxXQUFXLENBQUNTLEVBQUU7UUFDL0MsTUFBTUMsVUFBbUJWLFdBQVcsQ0FBQ1MsSUFBSSxFQUFFO1FBQzNDLE1BQU14RCxlQUFleUMsS0FBS1IsUUFBUTtRQUNsQyxJQUFJakMsaUJBQWlCLE1BQU07WUFDekIsTUFBTWEsWUFBWWIsYUFBYUssR0FBRyxDQUFDSjtZQUNuQyxJQUFJWSxjQUFjRixXQUFXO2dCQUMzQixNQUFNK0MsY0FBYzdDLFVBQVVXLEtBQUssQ0FBQyxFQUFFO2dCQUN0QyxJQUFJTixDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUN1QyxTQUFTQyxjQUFjO29CQUN0QyxtRUFBbUU7b0JBQ25FakIsT0FBTzVCO29CQUNQO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUsd0VBQXdFO1FBQ3hFLDhCQUE4QjtRQUM5QjtJQUNGO0lBRUE4QyxrQ0FDRWxCLE1BQ0FRLG1CQUNBRSxhQUNBQztBQUVKO0FBRUEsU0FBU08sa0NBQ1BsQixJQUFVLEVBQ1ZRLGlCQUFvQyxFQUNwQ0UsV0FBOEIsRUFDOUJDLFdBQTRCO0lBRTVCLDBFQUEwRTtJQUMxRSw0Q0FBNEM7SUFDNUMsTUFBTXBELGVBQWV5QyxLQUFLUixRQUFRO0lBQ2xDLE1BQU0yQixXQUFXbkIsS0FBS25CLElBQUk7SUFDMUIsSUFBSXRCLGlCQUFpQixNQUFNO1FBQ3pCLHdFQUF3RTtRQUN4RSxpRUFBaUU7UUFDakUsb0JBQW9CO1FBQ3BCLElBQUk0RCxhQUFhLE1BQU07WUFDckJDLHVCQUNFRCxVQUNBbkIsS0FBS2pCLEtBQUssRUFDVnlCLG1CQUNBRSxhQUNBQztZQUVGLHVEQUF1RDtZQUN2RFgsS0FBS25CLElBQUksR0FBRztRQUNkO1FBQ0E7SUFDRjtJQUNBLDJFQUEyRTtJQUMzRSx3REFBd0Q7SUFDeEQsTUFBTXdDLGlCQUFpQmIsaUJBQWlCLENBQUMsRUFBRTtJQUMzQyxNQUFNYyxzQkFBc0JaLFdBQVcsQ0FBQyxFQUFFO0lBRTFDLElBQUssTUFBTWxELG9CQUFvQmdELGtCQUFtQjtRQUNoRCxNQUFNZSx5QkFDSkYsY0FBYyxDQUFDN0QsaUJBQWlCO1FBQ2xDLE1BQU1nRSxtQkFDSkYsbUJBQW1CLENBQUM5RCxpQkFBaUI7UUFFdkMsTUFBTVksWUFBWWIsYUFBYUssR0FBRyxDQUFDSjtRQUNuQyxJQUFJWSxjQUFjRixXQUFXO1lBQzNCLE1BQU0rQyxjQUFjN0MsVUFBVVcsS0FBSyxDQUFDLEVBQUU7WUFDdEMsSUFDRU4sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDOEMsc0JBQXNCLENBQUMsRUFBRSxFQUFFTixnQkFDeENPLHFCQUFxQixRQUNyQkEscUJBQXFCdEQsV0FDckI7Z0JBQ0EsbUVBQW1FO2dCQUNuRSxPQUFPZ0Qsa0NBQ0w5QyxXQUNBbUQsd0JBQ0FDLGtCQUNBYjtZQUVKO1FBQ0Y7SUFDQSwyRUFBMkU7SUFDM0Usc0VBQXNFO0lBQ3RFLHdFQUF3RTtJQUN4RSw4QkFBOEI7SUFDaEM7QUFDRjtBQUVBLFNBQVNiLHVCQUNQRixXQUE4QixFQUM5Qi9DLFlBQXNDLEVBQ3RDQyxZQUE2QjtJQUU3QixNQUFNMkUsc0JBQXNCN0IsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTTNDLHVCQUF1QkosaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFFdkUsTUFBTU0saUJBQWlCLElBQUlFO0lBQzNCLElBQUssSUFBSUcsb0JBQW9CaUUsb0JBQXFCO1FBQ2hELE1BQU1DLG1CQUNKRCxtQkFBbUIsQ0FBQ2pFLGlCQUFpQjtRQUN2QyxNQUFNSyxvQkFDSloseUJBQXlCLE9BQ3JCQSxvQkFBb0IsQ0FBQ08saUJBQWlCLEdBQ3RDO1FBRU4sTUFBTW1FLGVBQWVELGdCQUFnQixDQUFDLEVBQUU7UUFDeEMsTUFBTUUsa0JBQWtCNUQsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDMkQ7UUFFN0MsTUFBTS9DLG9CQUFvQmtCLHVCQUN4QjRCLGtCQUNBN0Qsc0JBQXNCSyxZQUFZLE9BQU9MLG1CQUN6Q2Y7UUFHRixNQUFNZ0MscUJBQXNDLElBQUl6QjtRQUNoRHlCLG1CQUFtQkgsR0FBRyxDQUFDaUQsaUJBQWlCaEQ7UUFDeEN6QixlQUFld0IsR0FBRyxDQUFDbkIsa0JBQWtCc0I7SUFDdkM7SUFFQSw0RUFBNEU7SUFDNUUsbUVBQW1FO0lBQ25FLE1BQU0rQyxnQkFBZ0IxRSxlQUFlMkUsSUFBSSxLQUFLO0lBRTlDLE1BQU1DLG1CQUFtQmxGLGlCQUFpQixPQUFPQSxZQUFZLENBQUMsRUFBRSxHQUFHO0lBQ25FLE1BQU1tRix1QkFBdUJuRixpQkFBaUIsT0FBT0EsWUFBWSxDQUFDLEVBQUUsR0FBRztJQUN2RSxPQUFPO1FBQ0xvQyxVQUFVO1FBQ1Y5QixnQkFBZ0JBO1FBRWhCZ0MsYUFBYTRDLHFCQUFxQjdELFlBQVk2RCxtQkFBbUI7UUFDakVqRixjQUFjK0UsZ0JBQWdCL0UsZUFBZTtRQUM3Q3VDLFNBQVMyQyx5QkFBeUI5RCxZQUFZOEQsdUJBQXVCO1FBRXJFLHFFQUFxRTtRQUNyRSx3Q0FBd0M7UUFDeEM5QyxLQUFLK0M7UUFDTDdDLE1BQU15QyxnQkFBZ0JJLHNCQUFzQjtRQUM1QzNDLGtCQUFrQjtJQUNwQjtBQUNGO0FBRUEsU0FBUzhCLHVCQUNQYyxTQUFvQixFQUNwQkMsU0FBNEIsRUFDNUJDLFdBQThCLEVBQzlCMUIsV0FBOEIsRUFDOUJDLFdBQTRCO0lBRTVCLDhFQUE4RTtJQUM5RSw4RUFBOEU7SUFDOUUsNEVBQTRFO0lBQzVFLDhFQUE4RTtJQUM5RSw4REFBOEQ7SUFDOUQsNkJBQTZCO0lBQzdCLEVBQUU7SUFDRixxRUFBcUU7SUFDckUsOEVBQThFO0lBQzlFLGdFQUFnRTtJQUNoRSxNQUFNMEIsb0JBQW9CRixTQUFTLENBQUMsRUFBRTtJQUN0QyxNQUFNRyxzQkFBc0JGLFdBQVcsQ0FBQyxFQUFFO0lBQzFDLE1BQU1HLGVBQWU3QixXQUFXLENBQUMsRUFBRTtJQUVuQyw4RUFBOEU7SUFDOUUsNkVBQTZFO0lBQzdFLHVDQUF1QztJQUN2QyxNQUFNdkQsaUJBQWlCK0UsVUFBVS9FLGNBQWM7SUFDL0MsSUFBSyxJQUFJSyxvQkFBb0I2RSxrQkFBbUI7UUFDOUMsTUFBTUcsaUJBQ0pILGlCQUFpQixDQUFDN0UsaUJBQWlCO1FBQ3JDLE1BQU1pRixtQkFDSkgsbUJBQW1CLENBQUM5RSxpQkFBaUI7UUFDdkMsTUFBTWtGLFlBQ0pILFlBQVksQ0FBQy9FLGlCQUFpQjtRQUVoQyxNQUFNbUYsa0JBQWtCeEYsZUFBZVMsR0FBRyxDQUFDSjtRQUMzQyxNQUFNb0YsbUJBQW1CSixjQUFjLENBQUMsRUFBRTtRQUMxQyxNQUFNSyxzQkFBc0I3RSxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUM0RTtRQUVqRCxNQUFNRSxpQkFDSkgsb0JBQW9CekUsWUFDaEJ5RSxnQkFBZ0IvRSxHQUFHLENBQUNpRix1QkFDcEIzRTtRQUVOLElBQUk0RSxtQkFBbUI1RSxXQUFXO1lBQ2hDLElBQ0V1RSxxQkFBcUJ2RSxhQUNyQk8sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDbUUsa0JBQWtCSCxnQkFBZ0IsQ0FBQyxFQUFFLEdBQ2xEO2dCQUNBLElBQUlDLGNBQWN4RSxhQUFhd0UsY0FBYyxNQUFNO29CQUNqRCwrREFBK0Q7b0JBQy9EdEIsdUJBQ0UwQixnQkFDQU4sZ0JBQ0FDLGtCQUNBQyxXQUNBL0I7Z0JBRUosT0FBTztvQkFDTCxrRUFBa0U7b0JBQ2xFLG9FQUFvRTtvQkFDcEUsc0VBQXNFO29CQUN0RSwrQ0FBK0M7b0JBQy9Db0Msc0JBQXNCUCxnQkFBZ0JNLGdCQUFnQjtnQkFDeEQ7WUFDRixPQUFPO2dCQUNMLGtFQUFrRTtnQkFDbEUsdUJBQXVCO2dCQUN2QkMsc0JBQXNCUCxnQkFBZ0JNLGdCQUFnQjtZQUN4RDtRQUNGLE9BQU87UUFDTCx3RUFBd0U7UUFDeEUsZ0VBQWdFO1FBQ2hFLGlFQUFpRTtRQUNqRSx3REFBd0Q7UUFDMUQ7SUFDRjtJQUVBLDJFQUEyRTtJQUMzRSxxQkFBcUI7SUFDckIsTUFBTTVELE1BQU1nRCxVQUFVaEQsR0FBRztJQUN6QixNQUFNOEQscUJBQXFCdEMsV0FBVyxDQUFDLEVBQUU7SUFDekMsSUFBSXhCLFFBQVEsTUFBTTtRQUNoQixvRUFBb0U7UUFDcEUscUVBQXFFO1FBQ3JFZ0QsVUFBVWhELEdBQUcsR0FBRzhEO0lBQ2xCLE9BQU8sSUFBSUMsY0FBYy9ELE1BQU07UUFDN0IsMEVBQTBFO1FBQzFFLHNFQUFzRTtRQUN0RSxzRUFBc0U7UUFDdEVBLElBQUlnRSxPQUFPLENBQUNGO0lBQ2QsT0FBTztJQUNMLHVFQUF1RTtJQUN2RSxzRUFBc0U7SUFDeEU7SUFFQSw4RUFBOEU7SUFDOUUseUVBQXlFO0lBQ3pFLGNBQWM7SUFDZCxNQUFNNUQsT0FBTzhDLFVBQVU5QyxJQUFJO0lBQzNCLElBQUk2RCxjQUFjN0QsT0FBTztRQUN2QkEsS0FBSzhELE9BQU8sQ0FBQ3ZDO0lBQ2Y7QUFDRjtBQUVPLFNBQVNyRSxVQUFVMEQsSUFBVSxFQUFFYSxLQUFVO0lBQzlDLE1BQU1xQixZQUFZbEMsS0FBS25CLElBQUk7SUFDM0IsSUFBSXFELGNBQWMsTUFBTTtRQUN0QiwrQ0FBK0M7UUFDL0M7SUFDRjtJQUVBLE1BQU0zRSxlQUFleUMsS0FBS1IsUUFBUTtJQUNsQyxJQUFJakMsaUJBQWlCLE1BQU07UUFDekIsa0VBQWtFO1FBQ2xFLGFBQWE7UUFDYndGLHNCQUFzQi9DLEtBQUtqQixLQUFLLEVBQUVtRCxXQUFXckI7SUFDL0MsT0FBTztRQUNMLHNFQUFzRTtRQUN0RSwyRUFBMkU7UUFDM0UsNkJBQTZCO1FBQzdCLEtBQUssTUFBTXpDLGFBQWFiLGFBQWE0RixNQUFNLEdBQUk7WUFDN0M3RyxVQUFVOEIsV0FBV3lDO1FBQ3ZCO0lBQ0Y7SUFFQSx1REFBdUQ7SUFDdkRiLEtBQUtuQixJQUFJLEdBQUc7QUFDZDtBQUVBLFNBQVNrRSxzQkFDUG5ELFdBQThCLEVBQzlCc0MsU0FBb0IsRUFDcEJyQixLQUFVO0lBRVYsNkVBQTZFO0lBQzdFLHlDQUF5QztJQUN6QyxFQUFFO0lBQ0YsNkRBQTZEO0lBQzdELE1BQU1ZLHNCQUFzQjdCLFdBQVcsQ0FBQyxFQUFFO0lBQzFDLE1BQU16QyxpQkFBaUIrRSxVQUFVL0UsY0FBYztJQUMvQyxJQUFLLElBQUlLLG9CQUFvQmlFLG9CQUFxQjtRQUNoRCxNQUFNQyxtQkFDSkQsbUJBQW1CLENBQUNqRSxpQkFBaUI7UUFDdkMsTUFBTW1GLGtCQUFrQnhGLGVBQWVTLEdBQUcsQ0FBQ0o7UUFDM0MsSUFBSW1GLG9CQUFvQnpFLFdBQVc7WUFHakM7UUFDRjtRQUNBLE1BQU15RCxlQUFlRCxnQkFBZ0IsQ0FBQyxFQUFFO1FBQ3hDLE1BQU1FLGtCQUFrQjVELENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQzJEO1FBQzdDLE1BQU1tQixpQkFBaUJILGdCQUFnQi9FLEdBQUcsQ0FBQ2dFO1FBQzNDLElBQUlrQixtQkFBbUI1RSxXQUFXO1lBQ2hDNkUsc0JBQXNCckIsa0JBQWtCb0IsZ0JBQWdCakM7UUFDMUQsT0FBTztRQUNMLHdFQUF3RTtRQUN4RSx3REFBd0Q7UUFDMUQ7SUFDRjtJQUNBLE1BQU0zQixNQUFNZ0QsVUFBVWhELEdBQUc7SUFDekIsSUFBSStELGNBQWMvRCxNQUFNO1FBQ3RCLElBQUkyQixVQUFVLE1BQU07WUFDbEIsZ0RBQWdEO1lBQ2hEM0IsSUFBSWdFLE9BQU8sQ0FBQztRQUNkLE9BQU87WUFDTCwrQ0FBK0M7WUFDL0NoRSxJQUFJa0UsTUFBTSxDQUFDdkM7UUFDYjtJQUNGO0lBRUEsOEVBQThFO0lBQzlFLDRFQUE0RTtJQUM1RSwyRUFBMkU7SUFDM0UsNkRBQTZEO0lBQzdELE1BQU16QixPQUFPOEMsVUFBVTlDLElBQUk7SUFDM0IsSUFBSTZELGNBQWM3RCxPQUFPO1FBQ3ZCQSxLQUFLOEQsT0FBTyxDQUFDO0lBQ2Y7QUFDRjtBQUVPLFNBQVN6RyxxQ0FDZEMsWUFBdUIsRUFDdkJrRCxXQUE4QjtJQUU5QiwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUUsMENBQTBDO0lBQzFDLEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsOEVBQThFO0lBQzlFLHdEQUF3RDtJQUV4RCxNQUFNNkIsc0JBQXNCN0IsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTTFDLG9CQUFvQlIsYUFBYVMsY0FBYztJQUNyRCxNQUFNa0csb0JBQW9CLElBQUloRyxJQUFJSDtJQUNsQyxJQUFLLElBQUlNLG9CQUFvQmlFLG9CQUFxQjtRQUNoRCxNQUFNQyxtQkFDSkQsbUJBQW1CLENBQUNqRSxpQkFBaUI7UUFDdkMsTUFBTW1FLGVBQWVELGdCQUFnQixDQUFDLEVBQUU7UUFDeEMsTUFBTUUsa0JBQWtCNUQsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDMkQ7UUFDN0MsTUFBTWhFLHFCQUFxQlQsa0JBQWtCVSxHQUFHLENBQUNKO1FBQ2pELElBQUlHLHVCQUF1Qk8sV0FBVztZQUNwQyxNQUFNQyxvQkFBb0JSLG1CQUFtQkMsR0FBRyxDQUFDZ0U7WUFDakQsSUFBSXpELHNCQUFzQkQsV0FBVztnQkFDbkMsTUFBTVUsb0JBQW9CbkMscUNBQ3hCMEIsbUJBQ0F1RDtnQkFFRixNQUFNNUMscUJBQXFCLElBQUl6QixJQUFJTTtnQkFDbkNtQixtQkFBbUJILEdBQUcsQ0FBQ2lELGlCQUFpQmhEO2dCQUN4Q3lFLGtCQUFrQjFFLEdBQUcsQ0FBQ25CLGtCQUFrQnNCO1lBQzFDO1FBQ0Y7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxFQUFFO0lBQ0YsMEVBQTBFO0lBQzFFLDRFQUE0RTtJQUM1RSwyRUFBMkU7SUFDM0UsOEVBQThFO0lBQzlFLDZFQUE2RTtJQUM3RSxzQkFBc0I7SUFDdEIsTUFBTUksTUFBTXhDLGFBQWF3QyxHQUFHO0lBQzVCLE1BQU1vRSxvQkFBb0JMLGNBQWMvRCxRQUFRQSxJQUFJcUUsTUFBTSxLQUFLO0lBRS9ELE9BQU87UUFDTHRFLFVBQVU7UUFDVkM7UUFDQUUsTUFBTTFDLGFBQWEwQyxJQUFJO1FBRXZCdEMsY0FBY3dHLG9CQUFvQjVHLGFBQWFJLFlBQVksR0FBRztRQUM5RHFDLGFBQWFtRSxvQkFBb0I1RyxhQUFheUMsV0FBVyxHQUFHO1FBQzVERSxTQUFTaUUsb0JBQW9CNUcsYUFBYTJDLE9BQU8sR0FBRztRQUVwRCxrREFBa0Q7UUFDbERsQyxnQkFBZ0JrRztRQUNoQi9ELGtCQUFrQjtJQUNwQjtBQUNGO0FBRUEsTUFBTWtFLFdBQVdDO0FBOEJqQiw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDhFQUE4RTtBQUM5RSxtRUFBbUU7QUFDbkUsU0FBU1IsY0FBY1MsS0FBVTtJQUMvQixPQUFPQSxTQUFTQSxNQUFNQyxHQUFHLEtBQUtIO0FBQ2hDO0FBRUEsU0FBU3ZCO0lBQ1AsSUFBSWlCO0lBQ0osSUFBSUU7SUFDSixNQUFNUSxhQUFhLElBQUlDLFFBQXlCLENBQUNDLEtBQUtDO1FBQ3BEYixVQUFVWTtRQUNWVixTQUFTVztJQUNYO0lBQ0FILFdBQVdMLE1BQU0sR0FBRztJQUNwQkssV0FBV1YsT0FBTyxHQUFHLENBQUNRO1FBQ3BCLElBQUlFLFdBQVdMLE1BQU0sS0FBSyxXQUFXO1lBQ25DLE1BQU1TLGVBQXFDSjtZQUMzQ0ksYUFBYVQsTUFBTSxHQUFHO1lBQ3RCUyxhQUFhTixLQUFLLEdBQUdBO1lBQ3JCUixRQUFRUTtRQUNWO0lBQ0Y7SUFDQUUsV0FBV1IsTUFBTSxHQUFHLENBQUN2QztRQUNuQixJQUFJK0MsV0FBV0wsTUFBTSxLQUFLLFdBQVc7WUFDbkMsTUFBTVUsY0FBbUNMO1lBQ3pDSyxZQUFZVixNQUFNLEdBQUc7WUFDckJVLFlBQVlDLE1BQU0sR0FBR3JEO1lBQ3JCdUMsT0FBT3ZDO1FBQ1Q7SUFDRjtJQUNBK0MsV0FBV0QsR0FBRyxHQUFHSDtJQUNqQixPQUFPSTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcHItbmF2aWdhdGlvbnMudHM/NmE1NiJdLCJuYW1lcyI6WyJhYm9ydFRhc2siLCJsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsIm9sZENhY2hlTm9kZSIsIm9sZFJvdXRlclN0YXRlIiwibmV3Um91dGVyU3RhdGUiLCJwcmVmZXRjaERhdGEiLCJwcmVmZXRjaEhlYWQiLCJvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwibmV3Um91dGVyU3RhdGVDaGlsZHJlbiIsInByZWZldGNoRGF0YUNoaWxkcmVuIiwib2xkUGFyYWxsZWxSb3V0ZXMiLCJwYXJhbGxlbFJvdXRlcyIsInByZWZldGNoUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbiIsInRhc2tDaGlsZHJlbiIsInBhcmFsbGVsUm91dGVLZXkiLCJuZXdSb3V0ZXJTdGF0ZUNoaWxkIiwib2xkUm91dGVyU3RhdGVDaGlsZCIsIm9sZFNlZ21lbnRNYXBDaGlsZCIsImdldCIsInByZWZldGNoRGF0YUNoaWxkIiwibmV3U2VnbWVudENoaWxkIiwibmV3U2VnbWVudEtleUNoaWxkIiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJvbGRTZWdtZW50Q2hpbGQiLCJ1bmRlZmluZWQiLCJvbGRDYWNoZU5vZGVDaGlsZCIsInRhc2tDaGlsZCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJzcGF3blBlbmRpbmdUYXNrIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInNwYXduUmV1c2VkVGFzayIsIm1hdGNoU2VnbWVudCIsInNwYXduVGFza0Zvck1pc3NpbmdEYXRhIiwic2V0IiwibmV3Q2FjaGVOb2RlQ2hpbGQiLCJub2RlIiwibmV3U2VnbWVudE1hcENoaWxkIiwicm91dGUiLCJuZXdDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsImxvYWRpbmciLCJsYXp5RGF0YVJlc29sdmVkIiwicGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbiIsImNoaWxkcmVuIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsInJvdXRlclN0YXRlIiwicGVuZGluZ0NhY2hlTm9kZSIsImNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUiLCJyZXVzZWRSb3V0ZXJTdGF0ZSIsInRhc2siLCJyZXNwb25zZVByb21pc2UiLCJ0aGVuIiwicmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJzZWdtZW50UGF0aCIsInNsaWNlIiwic2VydmVyUm91dGVyU3RhdGUiLCJsZW5ndGgiLCJkeW5hbWljRGF0YSIsImR5bmFtaWNIZWFkIiwid3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayIsImVycm9yIiwicm9vdFRhc2siLCJpIiwic2VnbWVudCIsInRhc2tTZWdtZW50IiwiZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkIiwidGFza05vZGUiLCJmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlIiwic2VydmVyQ2hpbGRyZW4iLCJkeW5hbWljRGF0YUNoaWxkcmVuIiwic2VydmVyUm91dGVyU3RhdGVDaGlsZCIsImR5bmFtaWNEYXRhQ2hpbGQiLCJyb3V0ZXJTdGF0ZUNoaWxkcmVuIiwicm91dGVyU3RhdGVDaGlsZCIsInNlZ21lbnRDaGlsZCIsInNlZ21lbnRLZXlDaGlsZCIsImlzTGVhZlNlZ21lbnQiLCJzaXplIiwibWF5YmVQcmVmZXRjaFJzYyIsIm1heWJlUHJlZmV0Y2hMb2FkaW5nIiwiY3JlYXRlRGVmZXJyZWRSc2MiLCJjYWNoZU5vZGUiLCJ0YXNrU3RhdGUiLCJzZXJ2ZXJTdGF0ZSIsInRhc2tTdGF0ZUNoaWxkcmVuIiwic2VydmVyU3RhdGVDaGlsZHJlbiIsImRhdGFDaGlsZHJlbiIsInRhc2tTdGF0ZUNoaWxkIiwic2VydmVyU3RhdGVDaGlsZCIsImRhdGFDaGlsZCIsInNlZ21lbnRNYXBDaGlsZCIsInRhc2tTZWdtZW50Q2hpbGQiLCJ0YXNrU2VnbWVudEtleUNoaWxkIiwiY2FjaGVOb2RlQ2hpbGQiLCJhYm9ydFBlbmRpbmdDYWNoZU5vZGUiLCJkeW5hbWljU2VnbWVudERhdGEiLCJpc0RlZmVycmVkUnNjIiwicmVzb2x2ZSIsInZhbHVlcyIsInJlamVjdCIsIm5ld1BhcmFsbGVsUm91dGVzIiwic2hvdWxkVXNlUHJlZmV0Y2giLCJzdGF0dXMiLCJERUZFUlJFRCIsIlN5bWJvbCIsInZhbHVlIiwidGFnIiwicGVuZGluZ1JzYyIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJmdWxmaWxsZWRSc2MiLCJyZWplY3RlZFJzYyIsInJlYXNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n")},"(ssr)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchCacheEntryForInitialLoad: function() {\n        return createPrefetchCacheEntryForInitialLoad;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to \'/\'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKey(url, nextUrl) {\n    const pathnameFromUrl = (0, _createhreffromurl.createHrefFromUrl)(url, false);\n    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n    if (nextUrl) {\n        return nextUrl + "%" + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;\n    let existingCacheEntry = undefined;\n    // We first check if there\'s a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);\n    const interceptionData = prefetchCache.get(interceptionCacheKey);\n    if (interceptionData) {\n        existingCacheEntry = interceptionData;\n    } else {\n        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n        const prefetchCacheKey = createPrefetchCacheKey(url);\n        const prefetchData = prefetchCache.get(prefetchCacheKey);\n        if (prefetchData) {\n            existingCacheEntry = prefetchData;\n        }\n    }\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is "full" and the current cache entry wasn\'t, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            return createLazyPrefetchEntry({\n                tree,\n                url,\n                buildId,\n                nextUrl,\n                prefetchCache,\n                // If we didn\'t get an explicit prefetch kind, we want to set a temporary kind\n                // rather than assuming the same intent as the previous entry, to be consistent with how we\n                // lazily create prefetch entries when intent is left unspecified.\n                kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn\'t have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We\'ve determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn\'t return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        kind: kind || // in dev, there\'s never gonna be a prefetch entry so we want to prefetch here\n        ( true ? _routerreducertypes.PrefetchKind.AUTO : 0)\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don\'t have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache } = param;\n    const existingCacheKey = createPrefetchCacheKey(url);\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn\'t an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, nextUrl);\n    prefetchCache.set(newCacheKey, existingCacheEntry);\n    prefetchCache.delete(existingCacheKey);\n}\nfunction createPrefetchCacheEntryForInitialLoad(param) {\n    let { nextUrl, tree, prefetchCache, url, kind, data } = param;\n    const [, , , intercept] = data;\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            const [, , , intercepted] = prefetchResponse;\n            if (intercepted) {\n                prefixExistingPrefetchCacheEntry({\n                    url,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 30 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number("30") * 1000;\nconst STATIC_STALETIME_MS = Number("300") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For "auto" prefetching, we\'ll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a "lazy fetch" for the full data.\n    if (kind === "auto") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for "full" prefetching, we\'ll re-use the cache entry data for up to `static` staletime window.\n    if (kind === "full") {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcmVmZXRjaC1jYWNoZS11dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFtSmdCQSx3Q0FBc0M7ZUFBdENBOztJQTVHQUMsK0JBQTZCO2VBQTdCQTs7SUFpTUFDLG9CQUFrQjtlQUFsQkE7OzsrQ0F4T2tCO2lEQUkzQjtnREFNQTs2Q0FDdUI7QUFFOUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsdUJBQXVCQyxHQUFRLEVBQUVDLE9BQXVCO0lBQy9ELE1BQU1DLGtCQUFrQkMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUN2Q0gsS0FFQTtJQUdGLCtGQUErRjtJQUMvRixJQUFJQyxTQUFTO1FBQ1gsT0FBT0EsVUFBVyxNQUFHQztJQUN2QjtJQUVBLE9BQU9BO0FBQ1Q7QUFNTyxTQUFTTCw4QkFBOEJPLEtBYTdDO0lBYjZDLE1BQzVDSixHQUFHLEVBQ0hDLE9BQU8sRUFDUEksSUFBSSxFQUNKQyxPQUFPLEVBQ1BDLGFBQWEsRUFDYkMsSUFBSSxFQU9MLEdBYjZDSjtJQWM1QyxJQUFJSyxxQkFBcURDO0lBQ3pELDhFQUE4RTtJQUM5RSxrSkFBa0o7SUFDbEosaUlBQWlJO0lBQ2pJLE1BQU1DLHVCQUF1QlosdUJBQXVCQyxLQUFLQztJQUN6RCxNQUFNVyxtQkFBbUJMLGNBQWNNLEdBQUcsQ0FBQ0Y7SUFFM0MsSUFBSUMsa0JBQWtCO1FBQ3BCSCxxQkFBcUJHO0lBQ3ZCLE9BQU87UUFDTCwyR0FBMkc7UUFDM0csTUFBTUUsbUJBQW1CZix1QkFBdUJDO1FBQ2hELE1BQU1lLGVBQWVSLGNBQWNNLEdBQUcsQ0FBQ0M7UUFDdkMsSUFBSUMsY0FBYztZQUNoQk4scUJBQXFCTTtRQUN2QjtJQUNGO0lBRUEsSUFBSU4sb0JBQW9CO1FBQ3RCLDBEQUEwRDtRQUMxREEsbUJBQW1CTyxNQUFNLEdBQUdDLDRCQUE0QlI7UUFFeEQsK0RBQStEO1FBQy9E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QUluRCxTQUFTLFFBQVE7UUFDbkIsSUFBSTZCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZW9CLHFCQUFxQjtZQUNuRCxPQUFPZixvQkFBQUEsd0JBQXdCLENBQUNpQixRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPakIsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcmVmZXRjaC1jYWNoZS11dGlscy50cz9iNjIxIl0sIm5hbWVzIjpbImNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeUZvckluaXRpYWxMb2FkIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5IiwidXJsIiwibmV4dFVybCIsInBhdGhuYW1lRnJvbVVybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicGFyYW0iLCJ0cmVlIiwiYnVpbGRJZCIsInByZWZldGNoQ2FjaGUiLCJraW5kIiwiZXhpc3RpbmdDYWNoZUVudHJ5IiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0aW9uQ2FjaGVLZXkiLCJpbnRlcmNlcHRpb25EYXRhIiwiZ2V0IiwicHJlZmV0Y2hDYWNoZUtleSIsInByZWZldGNoRGF0YSIsInN0YXR1cyIsImdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyIsInN3aXRjaGVkVG9GdWxsUHJlZmV0Y2giLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJURU1QT1JBUlkiLCJwcm9jZXNzIiwiQVVUTyIsInByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhpc3RpbmdDYWNoZUtleSIsIm5ld0NhY2hlS2V5Iiwic2V0IiwiZGVsZXRlIiwiZGF0YSIsImludGVyY2VwdCIsInByZWZldGNoRW50cnkiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJlZmV0Y2hUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RVc2VkVGltZSIsImtleSIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsImZyZXNoIiwicHJlZmV0Y2hRdWV1ZSIsImVucXVldWUiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidGhlbiIsInByZWZldGNoUmVzcG9uc2UiLCJpbnRlcmNlcHRlZCIsImhyZWYiLCJwcmVmZXRjaENhY2hlRW50cnkiLCJleHBpcmVkIiwiRFlOQU1JQ19TVEFMRVRJTUVfTVMiLCJOdW1iZXIiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FIiwicmV1c2FibGUiLCJzdGFsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "fastRefreshReducer", ({\n    enumerable: true,\n    get: function() {\n        return fastRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn\'t get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        state.tree[0],\n        state.tree[1],\n        state.tree[2],\n        "refetch"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("REFRESH FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction fastRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst fastRefreshReducer =  false ? 0 : fastRefreshReducerImpl;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fast-refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9mYXN0LXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQTRIYUE7OztlQUFBQTs7O2lEQTVIdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHVCQUNQQyxLQUEyQixFQUMzQkMsTUFBeUI7SUFFekIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CO0lBQzdDLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQWlDLEVBQUNWLE1BQU1XLElBQUk7SUFFbkUsdURBQXVEO0lBQ3ZELHdDQUF3QztJQUN4Q0osTUFBTUssUUFBUSxHQUFHQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQ2xDLElBQUlDLElBQUlWLE1BQU1GLFNBQ2Q7UUFBQ0YsTUFBTVcsSUFBSSxDQUFDLEVBQUU7UUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7UUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7UUFBRTtLQUFVLEVBQ3hERixpQkFBaUJULE1BQU1lLE9BQU8sR0FBRyxNQUNqQ2YsTUFBTWdCLE9BQU87SUFHZixPQUFPVCxNQUFNSyxRQUFRLENBQUNLLElBQUksQ0FDeEIsQ0FBQUM7WUFBQyxDQUFDQyxZQUFZQyxxQkFBcUIsR0FBQUY7UUFDakMsNERBQTREO1FBQzVELElBQUksT0FBT0MsZUFBZSxVQUFVO1lBQ2xDLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJyQixPQUNBRyxTQUNBZ0IsWUFDQW5CLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSwrREFBK0Q7UUFDL0RoQixNQUFNSyxRQUFRLEdBQUc7UUFFakIsSUFBSVksY0FBY3hCLE1BQU1XLElBQUk7UUFDNUIsSUFBSWMsZUFBZXpCLE1BQU1PLEtBQUs7UUFFOUIsS0FBSyxNQUFNbUIsa0JBQWtCUCxXQUFZO1lBQ3ZDLG9GQUFvRjtZQUNwRixJQUFJTyxlQUFlQyxNQUFNLEtBQUssR0FBRztnQkFDL0Isb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU83QjtZQUNUO1lBRUEsbUdBQW1HO1lBQ25HLE1BQU0sQ0FBQzhCLFVBQVUsR0FBR0o7WUFDcEIsTUFBTUssVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUV6QztnQkFBQzthQUFHLEVBQ0pSLGFBQ0FNLFdBQ0E5QixNQUFNSyxZQUFZO1lBR3BCLElBQUkwQixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBcUIsRUFBQ2pDLE9BQU9DLFFBQVE2QjtZQUM5QztZQUVBLElBQUlJLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFBQ1YsYUFBYU8sVUFBVTtnQkFDckQsT0FBT1YsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnJCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNWSwyQkFBMkJmLHVCQUM3QmdCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ2hCLHdCQUNsQmlCO1lBRUosSUFBSWpCLHNCQUFzQjtnQkFDeEJqQixRQUFRRSxZQUFZLEdBQUc4QjtZQUN6QjtZQUNBLE1BQU1HLFVBQVVDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNkLGNBQWNsQixPQUFPbUI7WUFFckQsSUFBSVksU0FBUztnQkFDWG5DLFFBQVFJLEtBQUssR0FBR0E7Z0JBQ2hCa0IsZUFBZWxCO1lBQ2pCO1lBRUFKLFFBQVFxQyxXQUFXLEdBQUdUO1lBQ3RCNUIsUUFBUUUsWUFBWSxHQUFHRDtZQUV2Qm9CLGNBQWNPO1FBQ2hCO1FBQ0EsT0FBT1UsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDekMsT0FBT0c7SUFDOUIsR0FDQSxJQUFNSDtBQUVWO0FBRUEsU0FBUzBDLHVCQUNQMUMsS0FBMkIsRUFDM0IyQyxPQUEwQjtJQUUxQixPQUFPM0M7QUFDVDtBQUVPLE1BQU1GLHFCQUNYOEMsTUFBeUIsR0FDckJGLENBQUFBLEdBQ0EzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmFzdC1yZWZyZXNoLXJlZHVjZXIudHM/ZTViYiJdLCJuYW1lcyI6WyJmYXN0UmVmcmVzaFJlZHVjZXIiLCJmYXN0UmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsImN1cnJlbnRDYWNoZSIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImFwcGxpZWQiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiLCJmYXN0UmVmcmVzaFJlZHVjZXJOb29wIiwiX2FjdGlvbiIsInByb2Nlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "findHeadInCache", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, "");\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + "/" + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFJZ0JBOzs7ZUFBQUE7OztrREFGcUI7QUFFOUIsU0FBU0EsZ0JBQ2RDLEtBQWdCLEVBQ2hCQyxjQUFvQztJQUVwQyxPQUFPQyxvQkFBb0JGLE9BQU9DLGdCQUFnQjtBQUNwRDtBQUVBLFNBQVNDLG9CQUNQRixLQUFnQixFQUNoQkMsY0FBb0MsRUFDcENFLFNBQWlCO0lBRWpCLE1BQU1DLGFBQWFDLE9BQU9DLElBQUksQ0FBQ0wsZ0JBQWdCTSxNQUFNLEtBQUs7SUFDMUQsSUFBSUgsWUFBWTtRQUNkLDBFQUEwRTtRQUMxRSxPQUFPO1lBQUNKO1lBQU9HO1NBQVU7SUFDM0I7SUFDQSxJQUFLLE1BQU1LLE9BQU9QLGVBQWdCO1FBQ2hDLE1BQU0sQ0FBQ1EsU0FBU0Msb0JBQW9CLEdBQUdULGNBQWMsQ0FBQ08sSUFBSTtRQUMxRCxNQUFNRyxrQkFBa0JYLE1BQU1DLGNBQWMsQ0FBQ1csR0FBRyxDQUFDSjtRQUNqRCxJQUFJLENBQUNHLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDTDtRQUV0QyxNQUFNTSxZQUFZSixnQkFBZ0JDLEdBQUcsQ0FBQ0M7UUFDdEMsSUFBSSxDQUFDRSxXQUFXO1lBQ2Q7UUFDRjtRQUVBLE1BQU1DLE9BQU9kLG9CQUNYYSxXQUNBTCxxQkFDQVAsWUFBWSxNQUFNVTtRQUVwQixJQUFJRyxNQUFNO1lBQ1IsT0FBT0E7UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUudHM/OGJjZCJdLCJuYW1lcyI6WyJmaW5kSGVhZEluQ2FjaGUiLCJjYWNoZSIsInBhcmFsbGVsUm91dGVzIiwiZmluZEhlYWRJbkNhY2hlSW1wbCIsImtleVByZWZpeCIsImlzTGFzdEl0ZW0iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwia2V5Iiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJnZXQiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiY2FjaGVOb2RlIiwiaXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "getSegmentValue", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxPQUFnQjtJQUM5QyxPQUFPQyxNQUFNQyxPQUFPLENBQUNGLFdBQVdBLE9BQU8sQ0FBQyxFQUFFLEdBQUdBO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZS50cz9hYjhhIl0sIm5hbWVzIjpbImdldFNlZ21lbnRWYWx1ZSIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "hasInterceptionRouteInCurrentTree", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ "(ssr)/../node_modules/next/dist/server/future/helpers/interception-routes.js");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it\'s marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === "string" && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3FFQUdnQkE7OztlQUFBQTs7O2dEQUYyQjtBQUVwQyxTQUFTQSxrQ0FBa0NDLEtBRzlCO0lBSDhCLEtBQ2hEQyxTQUNBQyxlQUNrQixHQUg4QkY7SUFJaEQsd0dBQXdHO0lBQ3hHLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0gsWUFBYUEsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU87UUFDMUUsT0FBTztJQUNUO0lBRUEsb0VBQW9FO0lBQ3BFLElBQUksT0FBT0EsWUFBWSxZQUFZSSxDQUFBQSxHQUFBQSxvQkFBQUEsMEJBQTBCLEVBQUNKLFVBQVU7UUFDdEUsT0FBTztJQUNUO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLGdCQUFnQjtRQUNsQixJQUFLLE1BQU1JLE9BQU9KLGVBQWdCO1lBQ2hDLElBQUlILGtDQUFrQ0csY0FBYyxDQUFDSSxJQUFJLEdBQUc7Z0JBQzFELE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLnRzP2RmYzYiXSwibmFtZXMiOlsiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwicGFyYW0iLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ "(ssr)/../node_modules/next/dist/shared/lib/segment.js");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === "") {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nconst navigateReducer =  false ? 0 : navigateReducer_noPPR;\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it\'s been running in production for a while.\nfunction navigateReducer_noPPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === "push";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv="refresh">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById("__next-page-redirect")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove \'\'\n            const flightSegmentPathWithLeadingEmpty = [\n                "",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can\'t be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                let applied = false;\n                if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we\'re navigating to, to support instant loading navigations\n                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                    // while copying over the `loading` for the segment that contains the page data.\n                    // We only do this on subsequent reads, as otherwise there\'d be no loading data to re-use.\n                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                    // since we re-used the stale cache\'s loading state & refreshed the data,\n                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                    prefetchValues.lastUsedTime = Date.now();\n                } else {\n                    applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                }\n                const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                if (hardNavigate) {\n                    // Copy rsc for the root node of the cache.\n                    cache.rsc = currentCache.rsc;\n                    cache.prefetchRsc = currentCache.prefetchRsc;\n                    (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                    // Ensure the existing cache value is used when the cache was not invalidated.\n                    mutable.cache = cache;\n                } else if (applied) {\n                    mutable.cache = cache;\n                    // If we applied the cache, we update the "current cache" value so any other\n                    // segments in the FlightDataPath will be able to reference the updated cache.\n                    currentCache = cache;\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn\'t be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n// This is the experimental PPR implementation. It\'s closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === "push";\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        buildId: state.buildId,\n        prefetchCache: state.prefetchCache\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let [flightData, canonicalUrlOverride, _postponed] = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        // Handles case where `<meta http-equiv="refresh">` tag is present,\n        // which will trigger an MPA navigation.\n        if (document.getElementById("__next-page-redirect")) {\n            return handleExternalUrl(state, mutable, href, pendingPush);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        // TODO: In practice, this is always a single item array. We probably\n        // aren\'t going to every send multiple segments, at least not in this\n        // format. So we could remove the extra wrapper for now until\n        // that settles.\n        for (const flightDataPath of flightData){\n            const flightSegmentPath = flightDataPath.slice(0, -4);\n            // The one before last item is the router state tree patch\n            const treePatch = flightDataPath.slice(-3)[0];\n            // TODO-APP: remove \'\'\n            const flightSegmentPathWithLeadingEmpty = [\n                "",\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can\'t be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                    return handleExternalUrl(state, mutable, href, pendingPush);\n                }\n                if (// will always send back a static response that\'s rendered from\n                // the root. If for some reason it doesn\'t, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via updateCacheNodeOnNavigation. The current structure is just\n                // an incremental step.\n                flightDataPath.length === 3) {\n                    const prefetchedTree = flightDataPath[0];\n                    const seedData = flightDataPath[1];\n                    const head = flightDataPath[2];\n                    const task = (0, _pprnavigations.updateCacheNodeOnNavigation)(currentCache, currentTree, prefetchedTree, seedData, head);\n                    if (task !== null && task.node !== null) {\n                        // We\'ve created a new Cache Node tree that contains a prefetched\n                        // version of the next page. This can be rendered instantly.\n                        // Use the tree computed by updateCacheNodeOnNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        // The prefetched tree has dynamic holes in it. We initiate a\n                        // dynamic request to fill them in.\n                        //\n                        // Do not block on the result. We\'ll immediately render the Cache\n                        // Node tree and suspend on the dynamic parts. When the request\n                        // comes in, we\'ll fill in missing data and ping React to\n                        // re-render. Unlike the lazy fetching model in the non-PPR\n                        // implementation, this is modeled as a single React update +\n                        // streaming, rather than multiple top-level updates. (However,\n                        // even in the new model, we\'ll still need to sometimes update the\n                        // root multiple times per navigation, like if the server sends us\n                        // a different response than we expected. For now, we revert back\n                        // to the lazy fetching mechanism in that case.)\n                        (0, _pprnavigations.listenForDynamicRequest)(task, (0, _fetchserverresponse.fetchServerResponse)(url, currentTree, state.nextUrl, state.buildId));\n                        mutable.cache = newCache;\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = prefetchedTree;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there\'s no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we\'re navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there\'d be no loading data to re-use.\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache\'s loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the "current cache" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                }\n                currentTree = newTree;\n                for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                    const scrollableSegmentPath = [\n                        ...flightSegmentPath,\n                        ...subSegment\n                    ];\n                    // Filter out the __DEFAULT__ paths as they shouldn\'t be scrolled to in this case.\n                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                        scrollableSegments.push(scrollableSegmentPath);\n                    }\n                }\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        mutable.pendingPush = pendingPush;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWlDZ0JBLG1CQUFpQjtlQUFqQkE7O0lBcUVIQyxpQkFBZTtlQUFmQTs7O2lEQWpHdUI7K0NBQ0Y7bUVBQ29CO3lEQUNWO2dEQUNUO3lEQUNTO2dEQU9yQzsyQ0FDdUI7NkNBQ0U7NkNBQ0Y7dUNBQ087cUNBQ0Q7NENBSTdCO2dEQUlBOzhEQUMwQztBQUUxQyxTQUFTRCxrQkFDZEUsS0FBMkIsRUFDM0JDLE9BQWdCLEVBQ2hCQyxHQUFXLEVBQ1hDLFdBQW9CO0lBRXBCRixRQUFRRyxhQUFhLEdBQUc7SUFDeEJILFFBQVFJLFlBQVksR0FBR0g7SUFDdkJELFFBQVFFLFdBQVcsR0FBR0E7SUFDdEJGLFFBQVFLLGtCQUFrQixHQUFHQztJQUU3QixPQUFPQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNSLE9BQU9DO0FBQzlCO0FBRUEsU0FBU1EsMEJBQ1BDLGlCQUFvQztJQUVwQyxNQUFNQyxXQUFnQyxFQUFFO0lBQ3hDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHSDtJQUVsQyxJQUFJSSxPQUFPQyxJQUFJLENBQUNGLGdCQUFnQkcsTUFBTSxLQUFLLEdBQUc7UUFDNUMsT0FBTztZQUFDO2dCQUFDSjthQUFRO1NBQUM7SUFDcEI7SUFFQSxLQUFLLE1BQU0sQ0FBQ0ssa0JBQWtCQyxjQUFjLElBQUlKLE9BQU9LLE9BQU8sQ0FDNUROLGdCQUNDO1FBQ0QsS0FBSyxNQUFNTyxnQkFBZ0JYLDBCQUEwQlMsZUFBZ0I7WUFDbkUsbUVBQW1FO1lBQ25FLElBQUlOLFlBQVksSUFBSTtnQkFDbEJELFNBQVNVLElBQUksQ0FBQztvQkFBQ0o7dUJBQXFCRztpQkFBYTtZQUNuRCxPQUFPO2dCQUNMVCxTQUFTVSxJQUFJLENBQUM7b0JBQUNUO29CQUFTSzt1QkFB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S0FDdkQwRSxTQUFBQSxtQkFBbUIsRUFDbkI7d0JBQ0FwRixtQkFBbUJlLElBQUksQ0FBQ29FO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQXhGLFFBQVEwRixXQUFXLEdBQUdwQjtRQUN0QnRFLFFBQVFJLFlBQVksR0FBRzJELHVCQUNuQmpCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ2lCLHdCQUNsQmxCO1FBQ0o3QyxRQUFRRSxXQUFXLEdBQUdBO1FBQ3RCRixRQUFRSyxrQkFBa0IsR0FBR0E7UUFDN0JMLFFBQVEyRixZQUFZLEdBQUcvQztRQUN2QjVDLFFBQVEyQyxZQUFZLEdBQUdBO1FBRXZCLE9BQU9wQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNSLE9BQU9DO0lBQzlCLEdBQ0EsSUFBTUQ7QUFFViIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci50cz8xZmViIl0sIm5hbWVzIjpbImhhbmRsZUV4dGVybmFsVXJsIiwibmF2aWdhdGVSZWR1Y2VyIiwic3RhdGUiLCJtdXRhYmxlIiwidXJsIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwidW5kZWZpbmVkIiwiaGFuZGxlTXV0YWJsZSIsImdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2giLCJmbGlnaHRSb3V0ZXJQYXRjaCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJwYXJhbGxlbFJvdXRlIiwiZW50cmllcyIsImNoaWxkU2VnbWVudCIsInB1c2giLCJ0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzIiwibmV3Q2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsImFwcGxpZWRQYXRjaCIsInJzYyIsInByZWZldGNoUnNjIiwibG9hZGluZyIsIk1hcCIsInNlZ21lbnRQYXRoc1RvRmlsbCIsIm1hcCIsInNlZ21lbnRQYXRocyIsImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJuYXZpZ2F0ZVJlZHVjZXJfUFBSIiwibmF2aWdhdGVSZWR1Y2VyX25vUFBSIiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsIm5hdmlnYXRlVHlwZSIsInNob3VsZFNjcm9sbCIsImhhc2giLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJ0b1N0cmluZyIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwidHJlZSIsImJ1aWxkSWQiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsImRhdGEiLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsInRoZW4iLCJwYXJhbSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjdXJyZW50VHJlZSIsImNhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJzbGljZSIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInBhdGNoZWRUcmVlIiwiaGFzaEZyYWdtZW50IiwiX3Bvc3Rwb25lZCIsInByZWZldGNoZWRUcmVlIiwic2VlZERhdGEiLCJoZWFkIiwidGFzayIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsIm5vZGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJyb3V0ZSIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ "(ssr)/../node_modules/next/dist/client/components/app-router-headers.js");\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ "(ssr)/../node_modules/next/dist/client/components/promise-queue.js");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nfunction prefetchReducer(state, action) {\n    // let\'s prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    url.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        buildId: state.buildId\n    });\n    return state;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQVlhQSxlQUFhO2VBQWJBOztJQUVHQyxpQkFBZTtlQUFmQTs7OzhDQVRxQjswQ0FDUjtnREFJdEI7QUFFQSxNQUFNRCxnQkFBZ0IsSUFBSUUsY0FBQUEsWUFBWSxDQUFDO0FBRXZDLFNBQVNELGdCQUNkRSxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsNERBQTREO0lBQzVEQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQUNGLE1BQU1HLGFBQWE7SUFFdEMsTUFBTSxFQUFFQyxHQUFHLEVBQUUsR0FBR0g7SUFDaEJHLElBQUlDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDQyxrQkFBQUEsb0JBQW9CO0lBRTVDQyxDQUFBQSxHQUFBQSxvQkFBQUEsNkJBQTZCLEVBQUM7UUFDNUJKO1FBQ0FLLFNBQVNULE1BQU1TLE9BQU87UUFDdEJOLGVBQWVILE1BQU1HLGFBQWE7UUFDbENPLE1BQU1ULE9BQU9TLElBQUk7UUFDakJDLE1BQU1YLE1BQU1XLElBQUk7UUFDaEJDLFNBQVNaLE1BQU1ZLE9BQU87SUFDeEI7SUFFQSxPQUFPWjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLnRzPzQ1YmYiXSwibmFtZXMiOlsicHJlZmV0Y2hRdWV1ZSIsInByZWZldGNoUmVkdWNlciIsIlByb21pc2VRdWV1ZSIsInN0YXRlIiwiYWN0aW9uIiwicHJ1bmVQcmVmZXRjaENhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInVybCIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJidWlsZElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "refreshReducer", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn\'t get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [\n        currentTree[0],\n        currentTree[1],\n        currentTree[2],\n        "refetch"\n    ], includeNextUrl ? state.nextUrl : null, state.buildId);\n    return cache.lazyData.then(async (param)=>{\n        let [flightData, canonicalUrlOverride] = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === "string") {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("REFRESH FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[2];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                mutable.prefetchCache = new Map();\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZWZyZXNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztrREFtQmdCQTs7O2VBQUFBOzs7aURBbkJvQjsrQ0FDRjt5REFDVTt5REFDQTs2Q0FPVjsyQ0FDSjsyREFFZ0I7dUNBQ1Q7bURBQ0M7K0RBQ1k7NkRBQ0Y7QUFFekMsU0FBU0EsZUFDZEMsS0FBMkIsRUFDM0JDLE1BQXFCO0lBRXJCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdEO0lBQ25CLE1BQU1FLFVBQW1CLENBQUM7SUFDMUIsTUFBTUMsT0FBT0osTUFBTUssWUFBWTtJQUUvQixJQUFJQyxjQUFjTixNQUFNTyxJQUFJO0lBRTVCSixRQUFRSywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CO0lBRTdDLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQWlDLEVBQUNaLE1BQU1PLElBQUk7SUFFbkUsdURBQXVEO0lBQ3ZELHdDQUF3QztJQUN4Q0UsTUFBTUksUUFBUSxHQUFHQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQ2xDLElBQUlDLElBQUlYLE1BQU1GLFNBQ2Q7UUFBQ0ksV0FBVyxDQUFDLEVBQUU7UUFBRUEsV0FBVyxDQUFDLEVBQUU7UUFBRUEsV0FBVyxDQUFDLEVBQUU7UUFBRTtLQUFVLEVBQzNESyxpQkFBaUJYLE1BQU1nQixPQUFPLEdBQUcsTUFDakNoQixNQUFNaUIsT0FBTztJQUdmLE9BQU9SLE1BQU1JLFFBQVEsQ0FBQ0ssSUFBSSxDQUN4QixPQUFBQztZQUFPLENBQUNDLFlBQVlDLHFCQUFxQixHQUFBRjtRQUN2Qyw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPQyxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnRCLE9BQ0FHLFNBQ0FpQixZQUNBcEIsTUFBTXVCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRGYsTUFBTUksUUFBUSxHQUFHO1FBRWpCLEtBQUssTUFBTVksa0JBQWtCTCxXQUFZO1lBQ3ZDLG9GQUFvRjtZQUNwRixJQUFJSyxlQUFlQyxNQUFNLEtBQUssR0FBRztnQkFDL0Isb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU81QjtZQUNUO1lBRUEsbUdBQW1HO1lBQ25HLE1BQU0sQ0FBQzZCLFVBQVUsR0FBR0o7WUFDcEIsTUFBTUssVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUV6QztnQkFBQzthQUFHLEVBQ0p6QixhQUNBdUIsV0FDQTdCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSXlCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFxQixFQUFDaEMsT0FBT0MsUUFBUTRCO1lBQzlDO1lBRUEsSUFBSUksQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUFDM0IsYUFBYXdCLFVBQVU7Z0JBQ3JELE9BQU9SLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJ0QixPQUNBRyxTQUNBQyxNQUNBSixNQUFNdUIsT0FBTyxDQUFDQyxXQUFXO1lBRTdCO1lBRUEsTUFBTVUsMkJBQTJCYix1QkFDN0JjLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ2Qsd0JBQ2xCZTtZQUVKLElBQUlmLHNCQUFzQjtnQkFDeEJsQixRQUFRRSxZQUFZLEdBQUc2QjtZQUN6QjtZQUVBLDBEQUEwRDtZQUMxRCxNQUFNLENBQUNHLG1CQUFtQkMsS0FBSyxHQUFHYixlQUFlYyxLQUFLLENBQUMsQ0FBQztZQUV4RCw4RkFBOEY7WUFDOUYsSUFBSUYsc0JBQXNCLE1BQU07Z0JBQzlCLE1BQU1HLE1BQU1ILGlCQUFpQixDQUFDLEVBQUU7Z0JBQ2hDNUIsTUFBTStCLEdBQUcsR0FBR0E7Z0JBQ1ovQixNQUFNZ0MsV0FBVyxHQUFHO2dCQUNwQkMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUE2QixFQUMzQmpDLE9BRUEyQixXQUNBUCxXQUNBUSxtQkFDQUM7Z0JBRUZuQyxRQUFRd0MsYUFBYSxHQUFHLElBQUlDO1lBQzlCO1lBRUEsTUFBTUMsQ0FBQUEsR0FBQUEsaUNBQUFBLCtCQUErQixFQUFDO2dCQUNwQzdDO2dCQUNBOEMsYUFBYWhCO2dCQUNiaUIsY0FBY3RDO2dCQUNkRTtnQkFDQU4sY0FBY0YsUUFBUUUsWUFBWSxJQUFJTCxNQUFNSyxZQUFZO1lBQzFEO1lBRUFGLFFBQVFNLEtBQUssR0FBR0E7WUFDaEJOLFFBQVE2QyxXQUFXLEdBQUdsQjtZQUN0QjNCLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJFLGNBQWN3QjtRQUNoQjtRQUVBLE9BQU9tQixDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNqRCxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci50cz9iNWU3Il0sIm5hbWVzIjpbInJlZnJlc2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImN1cnJlbnRUcmVlIiwidHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibmV4dFVybCIsImJ1aWxkSWQiLCJ0aGVuIiwicGFyYW0iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsInNsaWNlIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "restoreReducer", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it\'s possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we\'ll continue to use the existing tree so the router doesn\'t get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        buildId: state.buildId,\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztrREFTZ0JBOzs7ZUFBQUE7OzsrQ0FUa0I7Z0RBTWU7NENBQ0k7QUFFOUMsU0FBU0EsZUFDZEMsS0FBMkIsRUFDM0JDLE1BQXFCO0lBRXJCLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBR0Y7SUFDdEIsTUFBTUcsT0FBT0MsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDSDtJQUMvQiwwRUFBMEU7SUFDMUUsNEZBQTRGO0lBQzVGLGdHQUFnRztJQUNoRyw2RkFBNkY7SUFDN0YsOERBQThEO0lBQzlELHlHQUF5RztJQUN6RyxNQUFNSSxnQkFBZ0JILFFBQVFILE1BQU1HLElBQUk7SUFFeEMsTUFBTUksV0FBV1AsTUFBTVEsS0FBSztJQUM1QixNQUFNQyxXQUFXQyxNQUFzQixHQUtuQ0csMkRBRjJEO0lBQzNELDJCQUEyQjtJQUMzQkEsQ0FBK0NQLEdBQy9DQztRQWlCT087SUFmWCxPQUFPO1FBQ0xDLFNBQVNmLE1BQU1lLE9BQU87UUFDdEIsb0JBQW9CO1FBQ3BCQyxjQUFjWjtRQUNkYSxTQUFTO1lBQ1BDLGFBQWE7WUFDYkMsZUFBZTtZQUNmLDZGQUE2RjtZQUM3RkMsNEJBQTRCO1FBQzlCO1FBQ0FDLG1CQUFtQnJCLE1BQU1xQixpQkFBaUI7UUFDMUNiLE9BQU9DO1FBQ1BhLGVBQWV0QixNQUFNc0IsYUFBYTtRQUNsQyx3QkFBd0I7UUFDeEJuQixNQUFNRztRQUNOaUIsU0FBU1QsQ0FBQUEsb0NBQUFBLENBQUFBLEdBQUFBLG9CQUFBQSxnQ0FBZ0MsRUFBQ1IsY0FBQUEsS0FBQUEsT0FBakNRLG9DQUFtRFosSUFBSXNCLFFBQVE7SUFDMUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLnRzP2FlNTYiXSwibmFtZXMiOlsicmVzdG9yZVJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInVybCIsInRyZWUiLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ0cmVlVG9SZXN0b3JlIiwib2xkQ2FjaGUiLCJjYWNoZSIsIm5ld0NhY2hlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJ1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24iLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsImJ1aWxkSWQiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByZWZldGNoQ2FjaGUiLCJuZXh0VXJsIiwicGF0aG5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "serverActionReducer", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ "(ssr)/../node_modules/next/dist/client/app-call-server.js");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ "(ssr)/../node_modules/next/dist/client/components/app-router-headers.js");\nconst _addbasepath = __webpack_require__(/*! ../../../add-base-path */ "(ssr)/../node_modules/next/dist/client/add-base-path.js");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from \'react-server-dom-webpack/client\'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from \'react-server-dom-webpack/client\'\nconst { createFromFetch, encodeReply } =  true ? __webpack_require__(/*! react-server-dom-webpack/client.edge */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-server-dom-webpack-client-edge.js") : 0;\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const body = await encodeReply(actionArgs);\n    const res = await fetch("", {\n        method: "POST",\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const location = res.headers.get("x-action-redirect");\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get("x-action-revalidated") || "[[],0,0]");\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? new URL((0, _addbasepath.addBasePath)(location), new URL(state.canonicalUrl, window.location.href)) : undefined;\n    let isFlightResponse = res.headers.get("content-type") === _approuterheaders.RSC_CONTENT_TYPE_HEADER;\n    if (isFlightResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            const [, actionFlightData] = response != null ? response : [];\n            return {\n                actionFlightData: actionFlightData,\n                redirectLocation,\n                revalidatedParts\n            };\n        }\n        // otherwise it\'s a tuple of [actionResult, actionFlightData]\n        const [actionResult, [, actionFlightData]] = response != null ? response : [];\n        return {\n            actionResult,\n            actionFlightData,\n            redirectLocation,\n            revalidatedParts\n        };\n    }\n    return {\n        redirectLocation,\n        revalidatedParts\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);\n    return mutable.inFlightServerAction.then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation } = param;\n        // Make sure the redirection is a push instead of a replace.\n        // Issue: https://github.com/vercel/next.js/issues/53911\n        if (redirectLocation) {\n            state.pushRef.pendingPush = true;\n            mutable.pendingPush = true;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === "string") {\n            // Handle case when navigating to page in `pages` from `app`\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.data as it has been resolved at this point.\n        mutable.inFlightServerAction = null;\n        if (redirectLocation) {\n            const newHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = newHref;\n        }\n        for (const flightDataPath of flightData){\n            // FlightDataPath with more than two items means unexpected Flight data was returned\n            if (flightDataPath.length !== 3) {\n                // TODO-APP: handle this case better\n                console.log("SERVER ACTION APPLY FAILED");\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const [treePatch] = flightDataPath;\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ""\n            ], currentTree, treePatch, redirectLocation ? (0, _createhreffromurl.createHrefFromUrl)(redirectLocation) : state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            // The one before last item is the router state tree patch\n            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);\n            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (rsc !== null) {\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head);\n                await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                    state,\n                    updatedTree: newTree,\n                    updatedCache: cache,\n                    includeNextUrl: Boolean(nextUrl),\n                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                });\n                mutable.cache = cache;\n                mutable.prefetchCache = new Map();\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        resolve(actionResult);\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don\'t update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozt1REFvSmdCQTs7O2VBQUFBOzs7MkNBL0lXOzhDQU1wQjt5Q0FtQnFCOytDQUNNOzZDQUNBO3lEQUNVO3lEQUNBOzJDQUVkOzJEQUNnQjt1Q0FDVDsrREFDYTttREFDWjs2REFDVTtBQTdCaEQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxXQUFXLEVBQUUsR0FDcEMsS0FBMEIsR0FFdEJJLG1CQUFBQSxDQUFRLDJLQUVSQSxDQUFRO0FBaUNkLGVBQWVDLGtCQUNiQyxLQUEyQixFQUMzQkMsT0FBd0MsRUFDeENDLEtBQTRDO0lBQTVDLE1BQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFzQixHQUE1Q0Y7SUFFQSxNQUFNRyxPQUFPLE1BQU1YLFlBQVlVO0lBRS9CLE1BQU1FLE1BQU0sTUFBTUMsTUFBTSxJQUFJO1FBQzFCQyxRQUFRO1FBQ1JDLFNBQVM7WUFDUEMsUUFBUUMsa0JBQUFBLHVCQUF1QjtZQUMvQixDQUFDQyxrQkFBQUEsTUFBTSxDQUFDLEVBQUVUO1lBQ1YsQ0FBQ1Usa0JBQUFBLHNCQUFzQixDQUFDLEVBQUVDLG1CQUFtQkMsS0FBS0MsU0FBUyxDQUFDaEIsTUFBTWlCLElBQUk7WUFDdEUsR0FBSXRCLE1BQThCLEdBQzlCLENBRUEsR0FDQSxDQUFDLENBQUM7WUFDTixHQUFJTSxVQUNBO2dCQUNFLENBQUNrQixrQkFBQUEsUUFBUSxDQUFDLEVBQUVsQjtZQUNkLElBQ0EsQ0FBQyxDQUFDO1FBQ1I7UUFDQUk7SUFDRjtJQUVBLE1BQU1lLFdBQVdkLElBQUlHLE9BQU8sQ0FBQ1ksR0FBRyxDQUFDO0lBQ2pDLElBQUlDO0lBQ0osSUFBSTtRQUNGLE1BQU1DLG9CQUFv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Q0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CO2dCQUM3Q0QsTUFBTUQsR0FBRyxHQUFHQTtnQkFDWkMsTUFBTUUsV0FBVyxHQUFHO2dCQUNwQkMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUE2QixFQUMzQkgsT0FFQW5DLFdBQ0EwQixXQUNBSyxtQkFDQUM7Z0JBR0YsTUFBTU8sQ0FBQUEsR0FBQUEsaUNBQUFBLCtCQUErQixFQUFDO29CQUNwQzFFO29CQUNBMkUsYUFBYWI7b0JBQ2JjLGNBQWNOO29CQUNkTyxnQkFBZ0JDLFFBQVE3RTtvQkFDeEIrQixjQUFjYSxRQUFRYixZQUFZLElBQUloQyxNQUFNZ0MsWUFBWTtnQkFDMUQ7Z0JBRUFhLFFBQVF5QixLQUFLLEdBQUdBO2dCQUNoQnpCLFFBQVFrQyxhQUFhLEdBQUcsSUFBSUM7WUFDOUI7WUFFQW5DLFFBQVFvQyxXQUFXLEdBQUduQjtZQUN0QmhCLGNBQWNnQjtRQUNoQjtRQUVBdkIsUUFBUUc7UUFFUixPQUFPd0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDbEYsT0FBTzZDO0lBQzlCLEdBQ0EsQ0FBQ2pCO1FBQ0MsbUhBQW1IO1FBQ25IZ0IsT0FBT2hCO1FBRVAsT0FBTzVCO0lBQ1Q7QUFFSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyLnRzP2NmMTIiXSwibmFtZXMiOlsic2VydmVyQWN0aW9uUmVkdWNlciIsImNyZWF0ZUZyb21GZXRjaCIsImVuY29kZVJlcGx5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInJlcXVpcmUiLCJmZXRjaFNlcnZlckFjdGlvbiIsInN0YXRlIiwibmV4dFVybCIsInBhcmFtIiwiYWN0aW9uSWQiLCJhY3Rpb25BcmdzIiwiYm9keSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiQUNUSU9OIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiTkVYVF9VUkwiLCJsb2NhdGlvbiIsImdldCIsInJldmFsaWRhdGVkUGFydHMiLCJyZXZhbGlkYXRlZEhlYWRlciIsInBhcnNlIiwicGF0aHMiLCJ0YWciLCJjb29raWUiLCJlIiwicmVkaXJlY3RMb2NhdGlvbiIsIlVSTCIsImFkZEJhc2VQYXRoIiwiY2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsInVuZGVmaW5lZCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJyZXNwb25zZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FsbFNlcnZlciIsImFjdGlvbkZsaWdodERhdGEiLCJhY3Rpb25SZXN1bHQiLCJhY3Rpb24iLCJyZWplY3QiLCJtdXRhYmxlIiwiY3VycmVudFRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImluRmxpZ2h0U2VydmVyQWN0aW9uIiwidGhlbiIsImZsaWdodERhdGEiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJoYW5kbGVFeHRlcm5hbFVybCIsIm5ld0hyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJzbGljZSIsInJzYyIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJCb29sZWFuIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "serverPatchReducer", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-mutable.js");\nconst _approuter = __webpack_require__(/*! ../../app-router */ "(ssr)/../node_modules/next/dist/client/components/app-router.js");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse } = action;\n    const [flightData, overrideCanonicalUrl] = serverResponse;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === "string") {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const flightDataPath of flightData){\n        // Slices off the last segment (which is at -4) as it doesn\'t exist in the tree yet\n        const flightSegmentPath = flightDataPath.slice(0, -4);\n        const [treePatch] = flightDataPath.slice(-3, -2);\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            "",\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        if (newTree === null) {\n            return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createhreffromurl.createHrefFromUrl)(overrideCanonicalUrl) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQWdCZ0JBOzs7ZUFBQUE7OzsrQ0FoQmtCO3lEQUNVO3lEQUNBOzZDQU9WOzZDQUNGOzJDQUNGO3VDQUVPO21EQUNDO0FBRS9CLFNBQVNBLG1CQUNkQyxLQUEyQixFQUMzQkMsTUFBeUI7SUFFekIsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0Q7SUFDM0IsTUFBTSxDQUFDRSxZQUFZQyxxQkFBcUIsR0FBR0Y7SUFFM0MsTUFBTUcsVUFBbUIsQ0FBQztJQUUxQkEsUUFBUUMsMEJBQTBCLEdBQUc7SUFFckMsNERBQTREO0lBQzVELElBQUksT0FBT0gsZUFBZSxVQUFVO1FBQ2xDLE9BQU9JLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJQLE9BQ0FLLFNBQ0FGLFlBQ0FILE1BQU1RLE9BQU8sQ0FBQ0MsV0FBVztJQUU3QjtJQUVBLElBQUlDLGNBQWNWLE1BQU1XLElBQUk7SUFDNUIsSUFBSUMsZUFBZVosTUFBTWEsS0FBSztJQUU5QixLQUFLLE1BQU1DLGtCQUFrQlgsV0FBWTtRQUN2QyxtRkFBbUY7UUFDbkYsTUFBTVksb0JBQW9CRCxlQUFlRSxLQUFLLENBQUMsR0FBRyxDQUFDO1FBRW5ELE1BQU0sQ0FBQ0MsVUFBVSxHQUFHSCxlQUFlRSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDOUMsTUFBTUUsVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUV6QztZQUFDO2VBQU9KO1NBQWtCLEVBQzFCTCxhQUNBTyxXQUNBakIsTUFBTW9CLFlBQVk7UUFHcEIsSUFBSUYsWUFBWSxNQUFNO1lBQ3BCLE9BQU9HLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBcUIsRUFBQ3JCLE9BQU9DLFFBQVFnQjtRQUM5QztRQUVBLElBQUlLLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFBQ1osYUFBYVEsVUFBVTtZQUNyRCxPQUFPWCxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCUCxPQUNBSyxTQUNBTCxNQUFNb0IsWUFBWSxFQUNsQnBCLE1BQU1RLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLE1BQU1jLDJCQUEyQm5CLHVCQUM3Qm9CLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ3BCLHdCQUNsQnFCO1FBRUosSUFBSUYsMEJBQTBCO1lBQzVCbEIsUUFBUWUsWUFBWSxHQUFHRztRQUN6QjtRQUVBLE1BQU1WLFFBQW1CYSxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7UUFDN0NDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNmLGNBQWNDLE9BQU9DO1FBRXJDVCxRQUFRdUIsV0FBVyxHQUFHVjtRQUN0QmIsUUFBUVEsS0FBSyxHQUFHQTtRQUVoQkQsZUFBZUM7UUFDZkgsY0FBY1E7SUFDaEI7SUFFQSxPQUFPVyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUM3QixPQUFPSztBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXIudHM/OTExZSJdLCJuYW1lcyI6WyJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGFQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJzbGljZSIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJjYW5vbmljYWxVcmwiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/apply-flight-data.js");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ "(ssr)/../node_modules/next/dist/shared/lib/segment.js");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === "refresh" && // it\'s possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn\'t care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        [\n            rootTree[0],\n            rootTree[1],\n            rootTree[2],\n            "refetch"\n        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{\n            const flightData = fetchResponse[0];\n            if (typeof flightData !== "string") {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that\'s\n                    // just been created & has been written to, but hasn\'t been "committed" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I\'m not 100% sure of this decision, but it seems unlikely that we\'d want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== "refresh") {\n        tree[2] = path;\n        tree[3] = "refresh";\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWlIZ0JBLDBDQUF3QztlQUF4Q0E7O0lBdkZNQyxpQ0FBK0I7ZUFBL0JBOzs7NkNBdkJVO2lEQUNJO3FDQUNIO0FBcUIxQixlQUFlQSxnQ0FDcEJDLE9BQXdDO0lBRXhDLE1BQU1DLGtCQUFrQixJQUFJQztJQUM1QixNQUFNQyxvQ0FBb0M7UUFDeEMsR0FBR0gsT0FBTztRQUNWSSxVQUFVSixRQUFRSyxXQUFXO1FBQzdCSjtJQUNGO0FBQ0Y7QUFFQSxlQUFlRSxvQ0FBb0NHLEtBV2xEO0lBWGtELE1BQ2pEQyxLQUFLLEVBQ0xGLFdBQVcsRUFDWEcsWUFBWSxFQUNaQyxjQUFjLEVBQ2RSLGVBQWUsRUFDZkcsV0FBV0MsV0FBVyxFQUN0QkssWUFBWSxFQUliLEdBWGtESjtJQVlqRCxNQUFNLEdBQUdLLGdCQUFnQkMsYUFBYUMsY0FBYyxHQUFHUjtJQUN2RCxNQUFNUyxnQkFBZ0IsRUFBRTtJQUV4QixJQUNFRixlQUNBQSxnQkFBZ0JGLGdCQUNoQkcsa0JBQWtCLGFBQ2xCLDRGQUE0RjtJQUM1RixzREFBc0Q7SUFDdEQsQ0FBQ1osZ0JBQWdCYyxHQUFHLENBQUNILGNBQ3JCO1FBQ0FYLGdCQUFnQmUsR0FBRyxDQUFDSixhQUFhLDJCQUEyQjs7UUFFNUQsd0hBQXdIO1FBQ3hILGtJQUFrSTtRQUNsSSxNQUFNSyxlQUFlQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQ3RDLElBQUlDLElBQUlQLGFBQWFRLFNBQVNDLE1BQU0sR0FFcEMsOEhBQThIO1FBQzlIO1lBQUNqQixRQUFRLENBQUMsRUFBRTtZQUFFQSxRQUFRLENBQUMsRUFBRTtZQUFFQSxRQUFRLENBQUMsRUFBRTtZQUFFO1NBQVUsRUFDbERLLGlCQUFpQkYsTUFBTWUsT0FBTyxHQUFHLE1BQ2pDZixNQUFNZ0IsT0FBTyxFQUNiQyxJQUFJLENBQUMsQ0FBQ0M7WUFDTixNQUFNQyxhQUFhRCxhQUFhLENBQUMsRUFBRTtZQUNuQyxJQUFJLE9BQU9DLGVBQWUsVUFBVTtnQkFDbEMsS0FBSyxNQUFNQyxrQkFBa0JELFdBQVk7b0JBQ3ZDLHdGQUF3RjtvQkFDeEYsNEdBQTRHO29CQUM1Ryw0RUFBNEU7b0JBQzVFRSxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBZSxFQUFDcEIsY0FBY0EsY0FBY21CO2dCQUM5QztZQUNGLE9BQU87WUFDTCw0R0FBNEc7WUFDNUcsK0dBQStHO1lBQy9HLHNFQUFzRTtZQUN4RTtRQUNGO1FBRUFiLGNBQWNlLElBQUksQ0FBQ1o7SUFDckI7SUFFQSxJQUFLLE1BQU1hLE9BQU9uQixlQUFnQjtRQUNoQyxNQUFNb0IsdUJBQXVCNUIsb0NBQW9DO1lBQy9ESTtZQUNBRixhQUFhTSxjQUFjLENBQUNtQixJQUFJO1lBQ2hDdEI7WUFDQUM7WUFDQVI7WUFDQUc7WUFDQU07UUFDRjtRQUVBSSxjQUFjZSxJQUFJLENBQUNFO0lBQ3JCO0lBRUEsTUFBTUMsUUFBUUMsR0FBRyxDQUFDbkI7QUFDcEI7QUFRTyxTQUFTaEIseUNBQ2RvQyxJQUF1QixFQUN2QkMsSUFBWTtJQUVaLE1BQU0sQ0FBQ0MsU0FBU3pCLGtCQUFrQkUsY0FBYyxHQUFHcUI7SUFDbkQsb0dBQW9HO0lBQ3BHLElBQUlFLFFBQVFDLFFBQVEsQ0FBQ0MsU0FBQUEsZ0JBQWdCLEtBQUt6QixrQkFBa0IsV0FBVztRQUNyRXFCLElBQUksQ0FBQyxFQUFFLEdBQUdDO1FBQ1ZELElBQUksQ0FBQyxFQUFFLEdBQUc7SUFDWjtJQUVBLElBQUssTUFBTUosT0FBT25CLGVBQWdCO1FBQ2hDYix5Q0FBeUNhLGNBQWMsQ0FBQ21CLElBQUksRUFBRUs7SUFDaEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy50cz83ODg4Il0sIm5hbWVzIjpbImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwib3B0aW9ucyIsImZldGNoZWRTZWdtZW50cyIsIlNldCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsIiwicm9vdFRyZWUiLCJ1cGRhdGVkVHJlZSIsInBhcmFtIiwic3RhdGUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsImNhbm9uaWNhbFVybCIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFBhdGgiLCJyZWZldGNoTWFya2VyIiwiZmV0Y2hQcm9taXNlcyIsImhhcyIsImFkZCIsImZldGNoUHJvbWlzZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIm5leHRVcmwiLCJidWlsZElkIiwidGhlbiIsImZldGNoUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJhcHBseUZsaWdodERhdGEiLCJwdXNoIiwia2V5IiwicGFyYWxsZWxGZXRjaFByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwidHJlZSIsInBhdGgiLCJzZWdtZW50IiwiaW5jbHVkZXMiLCJQQUdFX1NFR01FTlRfS0VZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    isThenable: function() {\n        return isThenable;\n    }\n});\nconst ACTION_REFRESH = "refresh";\nconst ACTION_NAVIGATE = "navigate";\nconst ACTION_RESTORE = "restore";\nconst ACTION_SERVER_PATCH = "server-patch";\nconst ACTION_PREFETCH = "prefetch";\nconst ACTION_FAST_REFRESH = "fast-refresh";\nconst ACTION_SERVER_ACTION = "server-action";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind["AUTO"] = "auto";\n    PrefetchKind["FULL"] = "full";\n    PrefetchKind["TEMPORARY"] = "temporary";\n})(PrefetchKind || (PrefetchKind = {}));\nvar PrefetchCacheEntryStatus;\n(function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus["fresh"] = "fresh";\n    PrefetchCacheEntryStatus["reusable"] = "reusable";\n    PrefetchCacheEntryStatus["expired"] = "expired";\n    PrefetchCacheEntryStatus["stale"] = "stale";\n})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));\nfunction isThenable(value) {\n    // TODO: We don\'t gain anything from this abstraction. It\'s unsound, and only\n    // makes sense in the specific places where we use it. So it\'s better to keep\n    // the type coercion inline, instead of leaking this to other places in\n    // the codebase.\n    return value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFZYUEscUJBQW1CO2VBQW5CQTs7SUFKQUMsaUJBQWU7ZUFBZkE7O0lBR0FDLGlCQUFlO2VBQWZBOztJQUpBQyxnQkFBYztlQUFkQTs7SUFFQUMsZ0JBQWM7ZUFBZEE7O0lBSUFDLHNCQUFvQjtlQUFwQkE7O0lBSEFDLHFCQUFtQjtlQUFuQkE7Ozs7Ozs7O0lBdVFHQyxZQUFVO2VBQVZBOzs7QUExUVQsTUFBTUosaUJBQWlCO0FBQ3ZCLE1BQU1GLGtCQUFrQjtBQUN4QixNQUFNRyxpQkFBaUI7QUFDdkIsTUFBTUUsc0JBQXNCO0FBQzVCLE1BQU1KLGtCQUFrQjtBQUN4QixNQUFNRixzQkFBc0I7QUFDNUIsTUFBTUssdUJBQXVCOztVQXVJeEJHLFlBQUFBOzs7O0dBQUFBLGdCQUFBQSxDQUFBQSxlQUFBQSxDQUFBQSxDQUFBQTs7VUE4REFDLHdCQUFBQTs7Ozs7R0FBQUEsNEJBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxDQUFBQTtBQStETCxTQUFTRixXQUFXRyxLQUFVO0lBQ25DLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsdUVBQXVFO0lBQ3ZFLGdCQUFnQjtJQUNoQixPQUNFQSxTQUNDLFFBQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLGVBQy9DLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUUxQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMudHM/ZWYxYyJdLCJuYW1lcyI6WyJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsImlzVGhlbmFibGUiLCJQcmVmZXRjaEtpbmQiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJ2YWx1ZSIsInRoZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "reducer", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js");\nconst _fastrefreshreducer = __webpack_require__(/*! ./reducers/fast-refresh-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/fast-refresh-reducer.js");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_FAST_REFRESH:\n            {\n                return (0, _fastrefreshreducer.fastRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error("Unknown action");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  true ? serverReducer : 0;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQWlFYUE7OztlQUFBQTs7O2dEQXpETjs2Q0FNeUI7Z0RBQ0c7NENBQ0o7NENBQ0E7NkNBQ0M7Z0RBQ0c7aURBQ0M7QUFFcEM7O0NBRUMsR0FDRCxTQUFTQyxjQUNQQyxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsT0FBUUEsT0FBT0MsSUFBSTtRQUNqQixLQUFLQyxvQkFBQUEsZUFBZTtZQUFFO2dCQUNwQixPQUFPQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBZSxFQUFDSixPQUFPQztZQUNoQztRQUNBLEtBQUtJLG9CQUFBQSxtQkFBbUI7WUFBRTtnQkFDeEIsT0FBT0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFrQixFQUFDTixPQUFPQztZQUNuQztRQUNBLEtBQUtNLG9CQUFBQSxjQUFjO1lBQUU7Z0JBQ25CLE9BQU9DLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFjLEVBQUNSLE9BQU9DO1lBQy9CO1FBQ0EsS0FBS1Esb0JBQUFBLGNBQWM7WUFBRTtnQkFDbkIsT0FBT0MsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQWMsRUFBQ1YsT0FBT0M7WUFDL0I7UUFDQSxLQUFLVSxvQkFBQUEsbUJBQW1CO1lBQUU7Z0JBQ3hCLE9BQU9DLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBa0IsRUFBQ1osT0FBT0M7WUFDbkM7UUFDQSxLQUFLWSxvQkFBQUEsZUFBZTtZQUFFO2dCQUNwQixPQUFPQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBZSxFQUFDZCxPQUFPQztZQUNoQztRQUNBLEtBQUtjLG9CQUFBQSxvQkFBb0I7WUFBRTtnQkFDekIsT0FBT0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDaEIsT0FBT0M7WUFDcEM7UUFDQSwrREFBK0Q7UUFDL0Q7WUFDRSxNQUFNLElBQUlnQixNQUFNO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTQyxjQUNQbEIsS0FBMkIsRUFDM0JtQixPQUF1QjtJQUV2QixPQUFPbkI7QUFDVDtBQUdPLE1BQU1GLFVBQ1gsS0FBa0IsR0FBY29CLGdCQUFnQm5CLENBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci50cz8zYzY1Il0sIm5hbWVzIjpbInJlZHVjZXIiLCJjbGllbnRSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX05BVklHQVRFIiwibmF2aWdhdGVSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInNlcnZlclBhdGNoUmVkdWNlciIsIkFDVElPTl9SRVNUT1JFIiwicmVzdG9yZVJlZHVjZXIiLCJBQ1RJT05fUkVGUkVTSCIsInJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX0ZBU1RfUkVGUkVTSCIsImZhc3RSZWZyZXNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInByZWZldGNoUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwic2VydmVyQWN0aW9uUmVkdWNlciIsIkVycm9yIiwic2VydmVyUmVkdWNlciIsIl9hY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer.js\n')},"(ssr)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "shouldHardNavigate", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ "(ssr)/../node_modules/next/dist/client/components/match-segments.js");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn\'t match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQVFnQkE7OztlQUFBQTs7OzJDQUhhO0FBR3RCLFNBQVNBLG1CQUNkQyxpQkFBaUMsRUFDakNDLGlCQUFvQztJQUVwQyxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0Y7SUFDbEMsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0csZ0JBQWdCQyxpQkFBaUIsR0FBR0w7SUFLM0MseURBQXlEO0lBQ3pELElBQUksQ0FBQ00sQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDRixnQkFBZ0JGLFVBQVU7UUFDMUMsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQ2pDLE9BQU87UUFDVDtRQUVBLHNFQUFzRTtRQUN0RSxPQUFPO0lBQ1Q7SUFDQSxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUVoRCxJQUFJRCxhQUFhO1FBQ2YsT0FBTztJQUNUO0lBRUEsT0FBT1YsbUJBQ0xDLGtCQUFrQlcsS0FBSyxDQUFDLElBQ3hCUixjQUFjLENBQUNFLGlCQUFpQjtBQUVwQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi8uLi8uLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUudHM/MmU5ZiJdLCJuYW1lcyI6WyJzaG91bGRIYXJkTmF2aWdhdGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodFJvdXRlclN0YXRlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiY3VycmVudFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwibWF0Y2hTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwibGFzdFNlZ21lbnQiLCJsZW5ndGgiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n')},"(ssr)/../node_modules/next/dist/client/components/search-params.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDynamicallyTrackedSearchParams: function() {\n        return createDynamicallyTrackedSearchParams;\n    },\n    createUntrackedSearchParams: function() {\n        return createUntrackedSearchParams;\n    }\n});\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ "../../client/components/static-generation-async-storage.external");\nconst _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ "(ssr)/../node_modules/next/dist/server/app-render/dynamic-rendering.js");\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ "(ssr)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js");\nfunction createUntrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (store && store.forceStatic) {\n        return {};\n    } else {\n        return searchParams;\n    }\n}\nfunction createDynamicallyTrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // we assume we are in a route handler or page render. just return the searchParams\n        return searchParams;\n    } else if (store.forceStatic) {\n        // If we forced static we omit searchParams entirely. This is true both during SSR\n        // and browser render because we need there to be parity between these environments\n        return {};\n    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {\n        // during dynamic renders we don\'t actually have to track anything so we just return\n        // the searchParams directly. However if dynamic data access should error then we\n        // still want to track access. This covers the case in Dev where all renders are dynamic\n        // but we still want to error if you use a dynamic data source because it will fail the build\n        // or revalidate if you do.\n        return searchParams;\n    } else {\n        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because\n        // these can all be used to exfiltrate information about searchParams.\n        return new Proxy({}, {\n            get (target, prop, receiver) {\n                if (typeof prop === "string") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams." + prop);\n                }\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === "string") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams." + prop);\n                }\n                return Reflect.has(target, prop);\n            },\n            ownKeys (target) {\n                (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams");\n                return Reflect.ownKeys(target);\n            }\n        });\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2gtcGFyYW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWdDZ0JBLHNDQUFvQztlQUFwQ0E7O0lBbkJBQyw2QkFBMkI7ZUFBM0JBOzs7a0VBWDZCOzhDQUNKO3FDQUNWO0FBU3hCLFNBQVNBLDRCQUNkQyxZQUE0QjtJQUU1QixNQUFNQyxRQUFRQyxzQ0FBQUEsNEJBQTRCLENBQUNDLFFBQVE7SUFDbkQsSUFBSUYsU0FBU0EsTUFBTUcsV0FBVyxFQUFFO1FBQzlCLE9BQU8sQ0FBQztJQUNWLE9BQU87UUFDTCxPQUFPSjtJQUNUO0FBQ0Y7QUFVTyxTQUFTRixxQ0FDZEUsWUFBNEI7SUFFNUIsTUFBTUMsUUFBUUMsc0NBQUFBLDRCQUE0QixDQUFDQyxRQUFRO0lBQ25ELElBQUksQ0FBQ0YsT0FBTztRQUNWLG1GQUFtRjtRQUNuRixPQUFPRDtJQUNULE9BQU8sSUFBSUMsTUFBTUcsV0FBVyxFQUFFO1FBQzVCLGtGQUFrRjtRQUNsRixtRkFBbUY7UUFDbkYsT0FBTyxDQUFDO0lBQ1YsT0FBTyxJQUFJLENBQUNILE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLE1BQU1LLGtCQUFrQixFQUFFO1FBQ2pFLG9GQUFvRjtRQUNwRixpRkFBaUY7UUFDakYsd0ZBQXdGO1FBQ3hGLDZGQUE2RjtRQUM3RiwyQkFBMkI7UUFDM0IsT0FBT047SUFDVCxPQUFPO1FBQ0wsMkZBQTJGO1FBQzNGLHNFQUFzRTtRQUN0RSxPQUFPLElBQUlPLE1BQU0sQ0FBQyxHQUFxQjtZQUNyQ0MsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7Z0JBQ3hCLElBQUksT0FBT0QsU0FBUyxVQUFVO29CQUM1QkUsQ0FBQUEsR0FBQUEsa0JBQUFBLHdCQUF3QixFQUFDWCxPQUFPLGtCQUFnQlM7Z0JBQ2xEO2dCQUNBLE9BQU9HLFNBQUFBLGNBQWMsQ0FBQ0wsR0FBRyxDQUFDQyxRQUFRQyxNQUFNQztZQUMxQztZQUNBRyxLQUFJTCxNQUFNLEVBQUVDLElBQUk7Z0JBQ2QsSUFBSSxPQUFPQSxTQUFTLFVBQVU7b0JBQzVCRSxDQUFBQSxHQUFBQSxrQkFBQUEsd0JBQXdCLEVBQUNYLE9BQU8sa0JBQWdCUztnQkFDbEQ7Z0JBQ0EsT0FBT0ssUUFBUUQsR0FBRyxDQUFDTCxRQUFRQztZQUM3QjtZQUNBTSxTQUFRUCxNQUFNO2dCQUNaRyxDQUFBQSxHQUFBQSxrQkFBQUEsd0JBQXdCLEVBQUNYLE9BQU87Z0JBQ2hDLE9BQU9jLFFBQVFDLE9BQU8sQ0FBQ1A7WUFDekI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3NlYXJjaC1wYXJhbXMudHM/MTU5MiJdLCJuYW1lcyI6WyJjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMiLCJjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJzdG9yZSIsInN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsImZvcmNlU3RhdGljIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQiLCJSZWZsZWN0QWRhcHRlciIsImhhcyIsIlJlZmxlY3QiLCJvd25LZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/search-params.js\n')},"(ssr)/../node_modules/next/dist/client/components/static-generation-bailout.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = "NEXT_STATIC_GEN_BAILOUT";\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== "object" || error === null || !("code" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUVhQSx1QkFBcUI7ZUFBckJBOztJQUlHQyx5QkFBdUI7ZUFBdkJBOzs7QUFOaEIsTUFBTUMsMEJBQTBCO0FBRXpCLE1BQU1GLDhCQUE4Qkc7OzthQUN6QkMsSUFBQUEsR0FBT0Y7O0FBQ3pCO0FBRU8sU0FBU0Qsd0JBQ2RJLEtBQWM7SUFFZCxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLENBQUUsV0FBVUEsS0FBQUEsR0FBUTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LnRzPzRjMzEiXSwibmFtZXMiOlsiU3RhdGljR2VuQmFpbG91dEVycm9yIiwiaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCIsIkVycm9yIiwiY29kZSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/static-generation-bailout.js\n')},"(ssr)/../node_modules/next/dist/client/components/unresolved-thenable.js":(module,exports)=>{eval('/**\n * Create a "Thenable" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */ \nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "unresolvedThenable", ({\n    enumerable: true,\n    get: function() {\n        return unresolvedThenable;\n    }\n}));\nconst unresolvedThenable = {\n    then: ()=>{}\n};\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unresolved-thenable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91bnJlc29sdmVkLXRoZW5hYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7O3NEQUNZQTs7O2VBQUFBOzs7QUFBTixNQUFNQSxxQkFBcUI7SUFDaENDLE1BQU0sS0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy91bnJlc29sdmVkLXRoZW5hYmxlLnRzPzQwMzYiXSwibmFtZXMiOlsidW5yZXNvbHZlZFRoZW5hYmxlIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/unresolved-thenable.js\n')},"(ssr)/../node_modules/next/dist/client/components/use-reducer-with-devtools.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    useReducerWithReduxDevtools: function() {\n        return useReducerWithReduxDevtools;\n    },\n    useUnwrapState: function() {\n        return useUnwrapState;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "(ssr)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js"));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ "(ssr)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");\nconst _actionqueue = __webpack_require__(/*! ../../shared/lib/router/action-queue */ "(ssr)/../node_modules/next/dist/shared/lib/router/action-queue.js");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === "function") {\n                obj[key] = "fn()";\n                continue;\n            }\n            if (typeof value === "object" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = "FlightData";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === "object" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === "function") {\n                obj[key] = "fn()";\n                continue;\n            }\n            if (typeof value === "object" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty("_bundlerConfig")) {\n                    obj[key] = "FlightData";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction useUnwrapState(state) {\n    // reducer actions can be async, so sometimes we need to suspend until the state is resolved\n    if ((0, _routerreducertypes.isThenable)(state)) {\n        const result = (0, _react.use)(state);\n        return result;\n    }\n    return state;\n}\nfunction useReducerWithReduxDevtoolsNoop(initialState) {\n    return [\n        initialState,\n        ()=>{},\n        ()=>{}\n    ];\n}\nfunction useReducerWithReduxDevtoolsImpl(initialState) {\n    const [state, setState] = _react.default.useState(initialState);\n    const actionQueue = (0, _react.useContext)(_actionqueue.ActionQueueContext);\n    if (!actionQueue) {\n        throw new Error("Invariant: Missing ActionQueueContext");\n    }\n    const devtoolsConnectionRef = (0, _react.useRef)();\n    const enabledRef = (0, _react.useRef)();\n    (0, _react.useEffect)(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === "undefined") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 8000,\n            name: "next-router"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n            if (actionQueue) {\n                actionQueue.devToolsInstance = devtoolsConnectionRef.current;\n            }\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState,\n        actionQueue\n    ]);\n    const dispatch = (0, _react.useCallback)((action)=>{\n        if (!actionQueue.state) {\n            // we lazy initialize the mutable action queue state since the data needed\n            // to generate the state is not available when the actionQueue context is created\n            actionQueue.state = initialState;\n        }\n        actionQueue.dispatch(action, setState);\n    }, [\n        actionQueue,\n        initialState\n    ]);\n    // Sync is called after a state update in the HistoryUpdater,\n    // for debugging purposes. Since the reducer state may be a Promise,\n    // we let the app router use() it and sync on the resolved value if\n    // something changed.\n    // Using the `state` here would be referentially unstable and cause\n    // undesirable re-renders and history updates.\n    const sync = (0, _react.useCallback)((resolvedState)=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: "RENDER_SYNC"\n            }, normalizeRouterState(resolvedState));\n        }\n    }, []);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\nconst useReducerWithReduxDevtools =  false ? 0 : useReducerWithReduxDevtoolsNoop;\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTJLYUEsNkJBQTJCO2VBQTNCQTs7SUE3RkdDLGdCQUFjO2VBQWRBOzs7OzZFQTdFdUI7Z0RBT2hDO3lDQUM0QjtBQUluQyxTQUFTQyxxQkFBcUJDLEdBQVE7SUFDcEMsSUFBSUEsZUFBZUMsS0FBSztRQUN0QixNQUFNQyxNQUE4QixDQUFDO1FBQ3JDLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlKLElBQUlLLE9BQU8sR0FBSTtZQUN4QyxJQUFJLE9BQU9ELFVBQVUsWUFBWTtnQkFDL0JGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO2dCQUNYO1lBQ0Y7WUFDQSxJQUFJLE9BQU9DLFVBQVUsWUFBWUEsVUFBVSxNQUFNO2dCQUMvQyxJQUFJQSxNQUFNRSxRQUFRLEVBQUU7b0JBQ2xCSixHQUFHLENBQUNDLElBQUksR0FBR0MsTUFBTUUsUUFBUSxDQUFDQyxRQUFRO29CQUNsQztnQkFDRjtnQkFDQSxJQUFJSCxNQUFNSSxjQUFjLEVBQUU7b0JBQ3hCTixHQUFHLENBQUNDLElBQUksR0FBRztvQkFDWDtnQkFDRjtZQUNGO1lBQ0FELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSixxQkFBcUJLO1FBQ2xDO1FBQ0EsT0FBT0Y7SUFDVDtJQUVBLElBQUksT0FBT0YsUUFBUSxZQUFZQSxRQUFRLE1BQU07UUFDM0MsTUFBTUUsTUFBOEIsQ0FBQztRQUNyQyxJQUFLLE1BQU1DLE9BQU9ILElBQUs7WUFDckIsTUFBTUksUUFBUUosR0FBRyxDQUFDRyxJQUFJO1lBQ3RCLElBQUksT0FBT0MsVUFBVSxZQUFZO2dCQUMvQkYsR0FBRyxDQUFDQyxJQUFJLEdBQUc7Z0JBQ1g7WUFDRjtZQUNBLElBQUksT0FBT0MsVUFBVSxZQUFZQSxVQUFVLE1BQU07Z0JBQy9DLElBQUlBLE1BQU1FLFFBQVEsRUFB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Qyw4QkFDWCxNQUFrQixHQUNkc0IsQ0FBQUEsR0FDQUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMudHM/NGUzYiJdLCJuYW1lcyI6WyJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJ1c2VVbndyYXBTdGF0ZSIsIm5vcm1hbGl6ZVJvdXRlclN0YXRlIiwidmFsIiwiTWFwIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiJCR0eXBlb2YiLCJ0b1N0cmluZyIsIl9idW5kbGVyQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJzdGF0ZSIsImlzVGhlbmFibGUiLCJyZXN1bHQiLCJ1c2UiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbCIsInNldFN0YXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsImFjdGlvblF1ZXVlIiwidXNlQ29udGV4dCIsIkFjdGlvblF1ZXVlQ29udGV4dCIsIkVycm9yIiwiZGV2dG9vbHNDb25uZWN0aW9uUmVmIiwidXNlUmVmIiwiZW5hYmxlZFJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwiY29ubmVjdCIsImluc3RhbmNlSWQiLCJuYW1lIiwiaW5pdCIsImRldlRvb2xzSW5zdGFuY2UiLCJkaXNwYXRjaCIsInVzZUNhbGxiYWNrIiwiYWN0aW9uIiwic3luYyIsInJlc29sdmVkU3RhdGUiLCJzZW5kIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/components/use-reducer-with-devtools.js\n')},"(ssr)/../node_modules/next/dist/client/dev/noop-turbopack-hmr.js":(module,exports)=>{eval('// The Turbopack HMR client can\'t be properly omitted at the moment (WEB-1589),\n// so instead we remap its import to this file in webpack builds.\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "connect", ({\n    enumerable: true,\n    get: function() {\n        return connect;\n    }\n}));\nfunction connect() {}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=noop-turbopack-hmr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L25vb3AtdHVyYm9wYWNrLWhtci5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrRUFBK0U7QUFDL0UsaUVBQWlFOzs7OzsyQ0FDakRBOzs7ZUFBQUE7OztBQUFULFNBQVNBLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vc3JjL2NsaWVudC9kZXYvbm9vcC10dXJib3BhY2staG1yLnRzP2UzM2IiXSwibmFtZXMiOlsiY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/dev/noop-turbopack-hmr.js\n')},"(ssr)/../node_modules/next/dist/client/get-domain-locale.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "getDomainLocale", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ "(ssr)/../node_modules/next/dist/client/normalize-trailing-slash.js");\nconst basePath =  false || "";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFPZ0JBOzs7ZUFBQUE7OztvREFKMkI7QUFFM0MsTUFBTUMsV0FBV0MsTUFBbUMsSUFBZTtBQUU1RCxTQUFTRixnQkFDZEssSUFBWSxFQUNaQyxNQUF1QixFQUN2QkMsT0FBa0IsRUFDbEJDLGFBQThCO0lBRTlCLElBQUlOLEtBQStCLEVBQUUsRUFnQnJDLE1BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uLi8uLi9zcmMvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLnRzPzFkNGUiXSwibmFtZXMiOlsiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/get-domain-locale.js\n')},"(ssr)/../node_modules/next/dist/client/has-base-path.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nObject.defineProperty(exports, "hasBasePath", ({\n    enumerable: true,\n    get: function() {\n        return hasBasePath;\n    }\n}));\nconst _pathhasprefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ "(ssr)/../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js");\nconst basePath =  false || "";\nfunction hasBasePath(path) {\n    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGFzLWJhc2UtcGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUlnQkE7OztlQUFBQTs7OzJDQUpjO0FBRTlCLE1BQU1DLFdBQVdDLE1BQW1DLElBQWU7QUFFNUQsU0FBU0YsWUFBWUssSUFBWTtJQUN0QyxPQUFPQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNELE1BQU1KO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uL3NyYy9jbGllbnQvaGFzLWJhc2UtcGF0aC50cz9hMzEyIl0sIm5hbWVzIjpbImhhc0Jhc2VQYXRoIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJwYXRoSGFzUHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/next/dist/client/has-base-path.js\n')},"(rsc)/../node_modules/next/dist/client/components/render-from-template-context.js":(e,t,n)=>{let{createProxy:Q}=n("(rsc)/../node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");e.exports=Q("/Users/jamesmontgomery/Desktop/tierd-deployment/node_modules/next/dist/client/components/render-from-template-context.js")},"(rsc)/../node_modules/next/dist/client/components/search-params.js":(module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDynamicallyTrackedSearchParams: function() {\n        return createDynamicallyTrackedSearchParams;\n    },\n    createUntrackedSearchParams: function() {\n        return createUntrackedSearchParams;\n    }\n});\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ "../../client/components/static-generation-async-storage.external");\nconst _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ "(rsc)/../node_modules/next/dist/server/app-render/dynamic-rendering.js");\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ "(rsc)/../node_modules/next/dist/server/web/spec-extension/adapters/reflect.js");\nfunction createUntrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (store && store.forceStatic) {\n        return {};\n    } else {\n        return searchParams;\n    }\n}\nfunction createDynamicallyTrackedSearchParams(searchParams) {\n    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // we assume we are in a route handler or page render. just return the searchParams\n        return searchParams;\n    } else if (store.forceStatic) {\n        // If we forced static we omit searchParams entirely. This is true both during SSR\n        // and browser render because we need there to be parity between these environments\n        return {};\n    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {\n        // during dynamic renders we don\'t actually have to track anything so we just return\n        // the searchParams directly. However if dynamic data access should error then we\n        // still want to track access. This covers the case in Dev where all renders are dynamic\n        // but we still want to error if you use a dynamic data source because it will fail the build\n        // or revalidate if you do.\n        return searchParams;\n    } else {\n        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because\n        // these can all be used to exfiltrate information about searchParams.\n        return new Proxy({}, {\n            get (target, prop, receiver) {\n                if (typeof prop === "string") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams." + prop);\n                }\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === "string") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams." + prop);\n                }\n                return Reflect.has(target, prop);\n            },\n            ownKeys (target) {\n                (0, _dynamicrendering.trackDynamicDataAccessed)(store, "searchParams");\n                return Reflect.ownKeys(target);\n            }\n        });\n    }\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2gtcGFyYW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWdDZ0JBLHNDQUFvQztlQUFwQ0E7O0lBbkJBQyw2QkFBMkI7ZUFBM0JBOzs7a0VBWDZCOzhDQUNKO3FDQUNWO0FBU3hCLFNBQVNBLDRCQUNkQyxZQUE0QjtJQUU1QixNQUFNQyxRQUFRQyxzQ0FBQUEsNEJBQTRCLENBQUNDLFFBQVE7SUFDbkQsSUFBSUYsU0FBU0EsTUFBTUcsV0FBVyxFQUFFO1FBQzlCLE9BQU8sQ0FBQztJQUNWLE9BQU87UUFDTCxPQUFPSjtJQUNUO0FBQ0Y7QUFVTyxTQUFTRixxQ0FDZEUsWUFBNEI7SUFFNUIsTUFBTUMsUUFBUUMsc0NBQUFBLDRCQUE0QixDQUFDQyxRQUFRO0lBQ25ELElBQUksQ0FBQ0YsT0FBTztRQUNWLG1GQUFtRjtRQUNuRixPQUFPRDtJQUNULE9BQU8sSUFBSUMsTUFBTUcsV0FBVyxFQUFFO1FBQzVCLGtGQUFrRjtRQUNsRixtRkFBbUY7UUFDbkYsT0FBTyxDQUFDO0lBQ1YsT0FBTyxJQUFJLENBQUNILE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLE1BQU1LLGtCQUFrQixFQUFFO1FBQ2pFLG9GQUFvRjtRQUNwRixpRkFBaUY7UUFDakYsd0ZBQXdGO1FBQ3hGLDZGQUE2RjtRQUM3RiwyQkFBMkI7UUFDM0IsT0FBT047SUFDVCxPQUFPO1FBQ0wsMkZBQTJGO1FBQzNGLHNFQUFzRTtRQUN0RSxPQUFPLElBQUlPLE1BQU0sQ0FBQyxHQUFxQjtZQUNyQ0MsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7Z0JBQ3hCLElBQUksT0FBT0QsU0FBUyxVQUFVO29CQUM1QkUsQ0FBQUEsR0FBQUEsa0JBQUFBLHdCQUF3QixFQUFDWCxPQUFPLGtCQUFnQlM7Z0JBQ2xEO2dCQUNBLE9BQU9HLFNBQUFBLGNBQWMsQ0FBQ0wsR0FBRyxDQUFDQyxRQUFRQyxNQUFNQztZQUMxQztZQUNBRyxLQUFJTCxNQUFNLEVBQUVDLElBQUk7Z0JBQ2QsSUFBSSxPQUFPQSxTQUFTLFVBQVU7b0JBQzVCRSxDQUFBQSxHQUFBQSxrQkFBQUEsd0JBQXdCLEVBQUNYLE9BQU8sa0JBQWdCUztnQkFDbEQ7Z0JBQ0EsT0FBT0ssUUFBUUQsR0FBRyxDQUFDTCxRQUFRQztZQUM3QjtZQUNBTSxTQUFRUCxNQUFNO2dCQUNaRyxDQUFBQSxHQUFBQSxrQkFBQUEsd0JBQXdCLEVBQUNYLE9BQU87Z0JBQ2hDLE9BQU9jLFFBQVFDLE9BQU8sQ0FBQ1A7WUFDekI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi4vLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3NlYXJjaC1wYXJhbXMudHM/MTU5MiJdLCJuYW1lcyI6WyJjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMiLCJjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJzdG9yZSIsInN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsImZvcmNlU3RhdGljIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQiLCJSZWZsZWN0QWRhcHRlciIsImhhcyIsIlJlZmxlY3QiLCJvd25LZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/search-params.js\n')},"(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js":(module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = "NEXT_STATIC_GEN_BAILOUT";\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== "object" || error === null || !("code" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {\n    Object.defineProperty(exports.default, "__esModule", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUVhQSx1QkFBcUI7ZUFBckJBOztJQUlHQyx5QkFBdUI7ZUFBdkJBOzs7QUFOaEIsTUFBTUMsMEJBQTBCO0FBRXpCLE1BQU1GLDhCQUE4Qkc7OzthQUN6QkMsSUFBQUEsR0FBT0Y7O0FBQ3pCO0FBRU8sU0FBU0Qsd0JBQ2RJLEtBQWM7SUFFZCxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLENBQUUsV0FBVUEsS0FBQUEsR0FBUTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4uLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LnRzPzRjMzEiXSwibmFtZXMiOlsiU3RhdGljR2VuQmFpbG91dEVycm9yIiwiaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCIsIkVycm9yIiwiY29kZSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/next/dist/client/components/static-generation-bailout.js\n')}};